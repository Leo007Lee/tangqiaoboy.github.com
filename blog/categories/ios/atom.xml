<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 唐巧的技术博客]]></title>
  <link href="http://blog.devtang.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.devtang.com/"/>
  <updated>2013-10-16T10:53:47+08:00</updated>
  <id>http://blog.devtang.com/</id>
  <author>
    <name><![CDATA[唐巧]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objective-C对象模型及应用]]></title>
    <link href="http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/"/>
    <updated>2013-10-15T20:31:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/10/15/objective-c-object-model</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>原创文章，转载请注明出自<a href="http://blog.devtang.com">唐巧的技术博客</a>。</p>

<p>本文主要介绍Objective-C对象模型的实现细节，以及Objective-C语言对象模型中对<code>isa swizzling</code>和<code>method swizzling</code>的支持。希望本文能加深你对Objective-C对象的理解。</p>

<h2>ISA指针</h2>

<p>Objective-C是一门面向对象的编程语言。每一个对象都是一个类的实例。在Objective-C语言的内部，每一个对象都有一个名为isa的指针，指向该对象的类。每一个类描述了一系列它的实例的特点，包括成员变量的列表，成员函数的列表等。每一个对象都可以接受消息，而对象能够接收的消息列表是保存在它所对应的类中。</p>

<p>在XCode中按<code>Shift + Command + O</code>, 然后输入NSObject.h和objc.h，可以打开NSObject的定义头文件，通过头文件我们可以看到，NSObject就是一个包含isa指针的结构体，如下图所示：</p>

<!-- more -->


<p><img src="/images/class-nsobject-isa.jpg">
<img src="/images/class-objc-object-isa.jpg"></p>

<p>按照面向对象语言的设计原则，所有事物都应该是对象（严格来说Objective-C并没有完全做到这一点，因为它有象int, double这样的简单变量类型）。在Objective-C语言中，每一个类实际上也是一个对象。每一个类也有一个名为isa的指针。每一个类也可以接受消息，例如<code>[NSObject alloc]</code>，就是向NSObject这个类发送名为<code>alloc</code>消息。</p>

<p>在XCode中按<code>Shift + Command + O</code>, 然后输入runtime.h，可以打开Class的定义头文件，通过头文件我们可以看到，Class也是一个包含isa指针的结构体，如下图所示。（图中除了isa外还有其它成员变量，但那是为了兼容非2.0版的Objective-C的遗留逻辑，大家可以忽略它。）</p>

<p><img src="/images/class-objc-class-isa.jpg"></p>

<p>因为类也是一个对象，那它也必须是另一个类的实列，这个类就是元类(<code>metaclass</code>)。元类保存了类方法的列表。当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现，如果没有，则该元类会向它的父类查找该方法，直到一直找到继承链的头。</p>

<p>元类(<code>metaclass</code>)也是一个对象，那么元类的isa指针又指向哪里呢？为了设计上的完整，所有的元类的isa指针都会指向一个根元类(root <code>metaclass</code>)。根元类(root metaclass)本身的isa指针指向自己，这样就行成了一个闭环。上面提到，一个对象能够接收的消息列表是保存在它所对应的类中的。在实际编程中，我们几乎不会遇到向元类发消息的情况，那它的isa指针在实际上很少用到。不过这么设计保证了面向对象的干净，即所有事物都是对象，都有isa指针。</p>

<p>我们再来看看继承关系，由于类方法的定义是保存在元类(<code>metaclass</code>)中，而方法调用的规则是，如果该类没有一个方法的实现，则向它的父类继续查找。所以，为了保证父类的类方法可以在子类中可以被调用，所以子类的元类会继承父类的元类，换而言之，类对象和元类对象有着同样的继承关系。</p>

<p>我很想把关系说清楚一些，但是这块儿确实有点绕，下面这张图或许能够让大家对isa和继承的关系清楚一些（该图片来自<a href="http://www.sealiesoftware.com/blog/class%20diagram.pdf">这里</a>）</p>

<p><img src="/images/class-diagram.jpg"></p>

<p>该图中，最让人困惑的莫过于Root Class了。在实现中，Root Class是指NSObject，我们可以从图中看出：</p>

<ol>
<li>NSObject类包括它的对象实例方法。</li>
<li>NSObject的元类包括它的类方法，例如alloc方法。</li>
<li>NSObject的元类继承自NSObject类。</li>
<li>一个NSObject的类中的方法同时也会被NSObject的子类在查找方法时找到。</li>
</ol>


<h2>类的成员变量</h2>

<p>如果把类的实例看成一个C语言的结构体（struct），上面说的isa指针就是这个结构体的第一个成员变量，而类的其它成员变量依次排列在结构体中。排列顺序如下图所示（图片来自《iOS 6 Programming Pushing the Limits》）：</p>

<p><img src="/images/class-member.jpg"></p>

<p>为了验证该说法，我们在XCode中新建一个工程，在main.m中运行如下代码：</p>

<p>``` objc</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@interface Father : NSObject {</p>

<pre><code>int _father;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation Father</p>

<p>@end</p>

<p>@interface Child : Father {</p>

<pre><code>int _child;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation Child</p>

<p>@end</p>

<p>int main(int argc, char * argv[])
{</p>

<p>  Child * child = [[Child alloc] init];  <br/>
  @autoreleasepool {</p>

<pre><code>  // ...
</code></pre>

<p>  }
}
```</p>

<p>我们将断点下在 <code>@autoreleasepool</code> 处，然后在Console中输入<code>p *child</code>,则可以看到Xcode输出如下内容，这与我们上面的说法一致。</p>

<p>```
(lldb) p *child
(Child) $0 = {
  (Father) Father = {</p>

<pre><code>(NSObject) NSObject = {
  (Class) isa = Child
}
(int) _father = 0
</code></pre>

<p>  }
  (int) _child = 0
}
```</p>

<h2>可变与不可变</h2>

<p>因为对象在内存中的排布可以看成一个结构体，该结构体的大小并不能动态变化。所以无法在运行时动态给对象增加成员变量。</p>

<p>相对的，对象的方法定义都保存在类的可变区域中。Objective-C 2.0并未在头文件中将实现暴露出来，但在Objective-C 1.0中，我们可以看到方法的定义列表是一个名为 <code>methodLists</code>的指针的指针（如下图所示）。通过修改该指针指向的指针的值，就可以实现动态地为某一个类增加成员方法。这也是<code>Category</code>实现的原理。同时也说明了为什么<code>Category</code>只可为对象增加成员方法，却不能增加成员变量。</p>

<p><img src="/images/class-objc-class-isa.jpg"></p>

<p>需要特别说明一下，通过<code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code>方法可以变相地给对象增加成员变量，但由于实现机制不一样，所以并不是真正改变了对象的内存结构。</p>

<p>除了对象的方法可以动态修改，因为isa本身也只是一个指针，所以我们也可以在运行时动态地修改isa指针的值，达到替换对象整个行为的目的。不过该应用场景较少。</p>

<h2>系统相关API及应用</h2>

<h3>isa swizzling的应用</h3>

<p>系统提供的KVO的实现，就利用了动态地修改isa指针的值的技术。在<a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/KeyValueObserving/Articles/KVOImplementation.html">苹果的文档</a>中可以看到如下描述：</p>

<p><blockquote><p></p></p><p><p>Key-Value Observing Implementation Details</p></p><p><p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p></p><p><p>The isa pointer, as the name suggests, points to the object's class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p></p><p><p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p></p><p><p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p></p><p><p></p></blockquote></p>

<p><del>类似的，使用isa swizzling的技术的还有系统提供的Key-Value Coding（KVC）。</del> (谢谢大家指出错误，KVC并没有使用到isa swizzling)</p>

<h3>Method Swizzling API说明</h3>

<p>Objective-C提供了以下API来动态替换类方法或实例方法的实现：</p>

<ul>
<li><code>class_replaceMethod</code> 替换类方法的定义</li>
<li><code>method_exchangeImplementations</code> 交换2个方法的实现</li>
<li><code>method_setImplementation</code> 设置1个方法的实现</li>
</ul>


<p>这3个方法有一些细微的差别，给大家介绍如下：</p>

<ul>
<li><code>class_replaceMethod</code>在苹果的文档（如下图所示）中能看到，它有两种不同的行为。当类中没有想替换的原方法时，该方法会调用<code>class_addMethod</code>来为该类增加一个新方法，也因为如此，<code>class_replaceMethod</code>在调用时需要传入<code>types</code>参数，而<code>method_exchangeImplementations</code>和<code>method_setImplementation</code>却不需要。</li>
</ul>


<p><img src="/images/class-replace-method.jpg"></p>

<ul>
<li><code>method_exchangeImplementations</code> 的内部实现其实是调用了2次<code>method_setImplementation</code>方法，从苹果的文档中能清晰地了解到（如下图所示）</li>
</ul>


<p><img src="/images/class-method-exchange-imp.jpg"></p>

<p>从以上的区别我们可以总结出这3个API的使用场景:</p>

<ul>
<li><code>class_replaceMethod</code>, 当需要替换的方法可能有不存在的情况时，可以考虑使用该方法。</li>
<li><code>method_exchangeImplementations</code>，当需要交换2个方法的实现时使用。</li>
<li><code>method_setImplementation</code> 最简单的用法，当仅仅需要为一个方法设置其实现方式时使用。</li>
</ul>


<h3>使用示例</h3>

<p>我们在开发<a href="http://yuantiku.com">猿题库</a>客户端的笔记功能时，需要使用系统的<code>UIImagePickerController</code>。但是，我们发现，在iOS6.0.2系统下，系统提供的<code>UIImagePickerController</code>在iPad横屏下有转屏的Bug，造成其方向错误。具体的Bug详情可以见<a href="http://stackoverflow.com/questions/12522491/crash-on-presenting-uiimagepickercontroller-under-ios-6-0">这里</a>。</p>

<p>为了修复该Bug，我们需要替换<code>UIImagePickerController</code>的如下2个方法</p>

<p>``` objc
- (BOOL)shouldAutorotate;
- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;</p>

<p>```</p>

<p>我们先实现了一个名为<code>ImagePickerReplaceMethodsHolder</code>的类，用于定义替换后的方法和实现。如下所示：</p>

<p>``` objc</p>

<p>// ImagePickerReplaceMethodsHolder.h
@interface ImagePickerReplaceMethodsHolder : NSObject</p>

<ul>
<li>(BOOL)shouldAutorotate;</li>
<li>(UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;</li>
</ul>


<p>@end</p>

<p>// ImagePickerReplaceMethodsHolder.m
@implementation ImagePickerReplaceMethodsHolder</p>

<ul>
<li><p>(BOOL)shouldAutorotate {
  return NO;
}</p></li>
<li><p>(UIInterfaceOrientation)preferredInterfaceOrientationForPresentation {
  return UIInterfaceOrientationPortrait;
}</p></li>
</ul>


<p>@end</p>

<p>```</p>

<p>然后，我们在调用处，判断当前的iOS版本，对于[iOS6.0, iOS6.1)之间的版本，我们将<code>UIImagePickerController</code>的有问题的方法替换。具体代码如下：</p>

<p>``` objc</p>

<h1>define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v)  ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)</h1>

<h1>define SYSTEM_VERSION_LESS_THAN(v)                 ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)</h1>

<ul>
<li><p>(void)load {
  static dispatch_once_t onceToken;
  dispatch_once(&amp;onceToken, ^{</p>

<pre><code>  [self hackForImagePicker];
</code></pre>

<p>  });
}</p></li>
<li><p>(void)hackForImagePicker {
  // fix bug of image picker under iOS 6.0
  // http://stackoverflow.com/questions/12522491/crash-on-presenting-uiimagepickercontroller-under-ios-6-0
  if (SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@"6.0")</p>

<pre><code>  &amp;&amp; SYSTEM_VERSION_LESS_THAN(@"6.1")) {
  Method oldMethod1 = class_getInstanceMethod([UIImagePickerController class], @selector(shouldAutorotate));
  Method newMethod1 = class_getInstanceMethod([ImagePickerReplaceMethodsHolder class], @selector(shouldAutorotate));
  method_setImplementation(oldMethod1, method_getImplementation(newMethod1));

  Method oldMethod2 = class_getInstanceMethod([UIImagePickerController class], @selector(preferredInterfaceOrientationForPresentation));
  Method newMethod2 = class_getInstanceMethod([ImagePickerReplaceMethodsHolder class], @selector(preferredInterfaceOrientationForPresentation));
  method_setImplementation(oldMethod2, method_getImplementation(newMethod2));
</code></pre>

<p>  }
}</p></li>
</ul>


<p>```</p>

<p>通过如上代码，我们就针对iOS特定版本的有问题的系统库函数打了Patch，使问题得到解决。</p>

<h3>开源界的使用</h3>

<p>有少量不明真相的同学以为苹果在审核时会拒绝App使用以上API，这其实是对苹果的误解。使用如上API是安全的。另外，开源界也对以上方法都适当的使用。例如：</p>

<ul>
<li>著名的网络库<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>。AFNetworking网络库(v1.x版本)使用了class_replaceMethod方法（AFHTTPRequestOperation.m文件第105行）</li>
<li><a href="https://github.com/jverkoey/nimbus">Nimbus</a>。Nimbus是著名的工具类库，它在其core模块中提供了<code>NIRuntimeClassModifications.h</code>文件，用于提供上述API的封装。</li>
<li>国内的大众点评iOS客户端。该客户端使用了他们自己开发的基于Wax修改而来的<a href="https://github.com/mmin18/WaxPatch">WaxPatch</a>，WaxPatch可以实现通过服务器更新来动态修改客户端的逻辑。而WaxPatch主要是修改了wax中的wax_instance.m文件，在其中加入了class_replaceMethod来替换原始实现，从而实现修改客户端的原有行为。</li>
</ul>


<h2>总结</h2>

<p>通过本文，我们了解到了Objective-C语言的对象模型，以及Objective-C语言对象模型中对<code>isa swizzling</code>和<code>method swizzling</code>的支持。本文也通过具体的实例代码和开源项目，让我们对该对象模型提供的动态性有了更加深刻的认识。</p>

<h2>后记</h2>

<p>文章发表后，一些同行指出在ARM64的CPU下，isa的内部结构有变化。这点我是知道的，不过希望以后再撰文讨论。感兴趣的同学可以查看苹果今年WWDC2013的视频：《Session 404 Advanced in Objective-C》。</p>

<h3>参考链接</h3>

<ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html</a></li>
<li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html</a></li>
<li><a href="http://www.devalot.com/articles/2011/11/objc-object-model.html">http://www.devalot.com/articles/2011/11/objc-object-model.html</a></li>
<li><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html</a></li>
<li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html</a></li>
<li><a href="http://wwwmain.gnustep.org/resources/downloads.php">gunstep的实现源码</a></li>
<li><a href="http://algorithm.com.au/downloads/talks/objective-c-internals/objective-c-internals.pdf">http://algorithm.com.au/downloads/talks/objective-c-internals/objective-c-internals.pdf</a></li>
<li><a href="http://opensource.apple.com/source/objc4/objc4-532/runtime/">http://opensource.apple.com/source/objc4/objc4-532/runtime/</a></li>
<li><a href="https://github.com/AFNetworking/AFNetworking">https://github.com/AFNetworking/AFNetworking</a></li>
<li><a href="https://github.com/jverkoey/nimbus">https://github.com/jverkoey/nimbus</a></li>
<li><a href="https://github.com/mmin18/WaxPatch">https://github.com/mmin18/WaxPatch</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动态下载苹果提供的多种中文字体]]></title>
    <link href="http://blog.devtang.com/blog/2013/08/11/ios-asian-font-download-introduction/"/>
    <updated>2013-08-11T16:00:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/08/11/ios-asian-font-download-introduction</id>
    <content type="html"><![CDATA[<p><img src="/images/wawati-sample.jpg"></p>

<h2>引言</h2>

<p>在今年WWDC的内容公开之前，大家都以为iOS系统里面只有一种中文字体。为了达到更好的字体效果，有些应用在自己的应用资源包中加入了字体文件。但自己打包字体文件比较麻烦，原因在于：</p>

<p>1、字体文件通常比较大，10M - 20M是一个常见的字体库的大小。大部分的非游戏的app体积都集中在10M以内，因为字体文件的加入而造成应用体积翻倍让人感觉有些不值。如果只是很少量的按钮字体需要设置，可以用一些工具把使用到的汉字字体编码从字体库中抽取出来，以节省体积。但如果是一些变化的内容需要自定义的字体，那就只有打包整个字体库了。</p>

<p>2、中文的字体通常都是有版权的。在应用中加入特殊中文字体还需要处理相应的版权问题。对于一些小公司或个人开发者来说，这是一笔不小的开销。</p>

<p>以上两点造成App Store里面使用特殊中文字库的iOS应用较少。现在通常只有阅读类的应用才会使用特殊中文字库。</p>

<p>但其实从iOS6开始，苹果就支持动态下载中文字体到系统中。只是苹果一直没有公开相应的API。最终，相应的API在今年的WWDC大会上公开，接下来就让我们来一起了解这个功能。</p>

<!-- more -->


<h2>功能介绍</h2>

<p>使用动态下载中文字体的API可以动态地向iOS系统中添加字体文件，这些字体文件都是下载到系统的目录中（目录是<code>/private/var/mobile/Library/Assets/com_apple_MobileAsset_Font/</code>），所以并不会造成应用体积的增加。并且，由于字体文件是iOS系统提供的，也免去了字体使用版权的问题。虽然第一次下载相关的中文字体需要一些网络开销和下载时间，但是这些字体文件下载后可以在所有应用间共享，所以可以遇见到，随着该API使用的普及，大部分应用都不需要提示用户下载字体，因为很可能这些字体在之前就被其它应用下载下来了。</p>

<h2>字体列表</h2>

<p>在<a href="http://support.apple.com/kb/HT5484?viewlocale=zh_CN">这个链接</a>中，苹果列出了提供动态下载和使用中文字体文件列表。不过，由于下载的时候需要使用的名字是PostScript名称，所以如果你真正要动态下载相应的字体的话，还需要使用Mac内自带的应用“字体册“来获得相应字体的PostScript名称。如下显示了从”字体册“中获取《兰亭黑-简 特黑》字体的PostScript名称的截图：</p>

<p><img src="/images/font-postscript-name.jpg"></p>

<h2>API介绍</h2>

<p>苹果提供的动态下载代码的<a href="http://developer.apple.com/library/ios/#samplecode/DownloadFont/Listings/DownloadFont_ViewController_m.html">Demo工程</a> 链接在这里。将此Demo工程下载下来，即可学习相应API的使用。下面我对该工程中相应API做简单的介绍。</p>

<p>假如我们现在要下载娃娃体字体，它的PostScript名称为<code>DFWaWaSC-W5</code>。具体的步骤如下：</p>

<p>1、我们先判断该字体是否已经被下载下来了，代码如下：</p>

<p>``` objc</p>

<ul>
<li>(BOOL)isFontDownloaded:(NSString <em>)fontName {
  UIFont</em> aFont = [UIFont fontWithName:fontName size:12.0];
  if (aFont &amp;&amp; ([aFont.fontName compare:fontName] == NSOrderedSame

<pre><code>         || [aFont.familyName compare:fontName] == NSOrderedSame)) {
  return YES;
</code></pre>

  } else {

<pre><code>  return NO;
</code></pre>

<p>  }
}</p></li>
</ul>


<p>```</p>

<p>2、如果该字体下载过了，则可以直接使用。否则我们需要先准备下载字体API需要的一些参数，如下所示：</p>

<p>``` objc</p>

<p>// 用字体的PostScript名字创建一个Dictionary
NSMutableDictionary *attrs = [NSMutableDictionary dictionaryWithObjectsAndKeys:fontName, kCTFontNameAttribute, nil];</p>

<p>// 创建一个字体描述对象CTFontDescriptorRef
CTFontDescriptorRef desc = CTFontDescriptorCreateWithAttributes((__bridge CFDictionaryRef)attrs);</p>

<p>// 将字体描述对象放到一个NSMutableArray中
NSMutableArray *descs = [NSMutableArray arrayWithCapacity:0];
[descs addObject:(__bridge id)desc];
CFRelease(desc);</p>

<p>```</p>

<p>3、准备好上面的<code>descs</code>变量后，则可以进行字体的下载了，代码如下：</p>

<p>``` objc</p>

<p>__block BOOL errorDuringDownload = NO;</p>

<p>CTFontDescriptorMatchFontDescriptorsWithProgressHandler( (__bridge CFArrayRef)descs, NULL,  ^(CTFontDescriptorMatchingState state, CFDictionaryRef progressParameter) {</p>

<pre><code>double progressValue = [[(__bridge NSDictionary *)progressParameter objectForKey:(id)kCTFontDescriptorMatchingPercentage] doubleValue];

if (state == kCTFontDescriptorMatchingDidBegin) {
    NSLog(@"字体已经匹配");
} else if (state == kCTFontDescriptorMatchingDidFinish) {    
    if (!errorDuringDownload) {
        NSLog(@"字体%@ 下载完成", fontName);
    }
} else if (state == kCTFontDescriptorMatchingWillBeginDownloading) {
    NSLog(@"字体开始下载");
} else if (state == kCTFontDescriptorMatchingDidFinishDownloading) {
    NSLog(@"字体下载完成");
    dispatch_async( dispatch_get_main_queue(), ^ {
        // 可以在这里修改UI控件的字体
    });
} else if (state == kCTFontDescriptorMatchingDownloading) {
    NSLog(@"下载进度 %.0f%% ", progressValue);
} else if (state == kCTFontDescriptorMatchingDidFailWithError) {
    NSError *error = [(__bridge NSDictionary *)progressParameter objectForKey:(id)kCTFontDescriptorMatchingError];
    if (error != nil) {
        _errorMessage = [error description];
    } else {
        _errorMessage = @"ERROR MESSAGE IS NOT AVAILABLE!";
    }
    // 设置标志
    errorDuringDownload = YES;
    NSLog(@"下载错误: %@", _errorMessage);
}

return (BOOL)YES;
</code></pre>

<p>});</p>

<p>```</p>

<p>通常需要在下载完字体后开始使用字体，一般是将相应代码放到 kCTFontDescriptorMatchingDidFinish 那个条件中做，可以象苹果官网的示例代码上那样，用GCD来改UI的逻辑，也可以发Notification来通知相应的Controller。</p>

<p>以下是通过以上示例代码下载下来的娃娃体字体截图：</p>

<p><img src="/images/wawati-sample.jpg"></p>

<h2>iOS版本限制</h2>

<p>以上代码只能运行在iOS6以上的系统，但当前还有不少用户是iOS5的系统。不过，随着苹果在WWDC2013中推出iOS7的beta版，很多人都期待着使用iOS7。从历史数据上看，苹果iOS新版本推出后，通常3个月内就可以达到50%以上的使用比例。所以，可以遇见到在今年年底，iOS5的用户将所剩无几。如果我们打算在年底只支持iOS6以上的系统，那么就可以通过上面介绍的方法使用大量中文字体来美化你的应用。</p>

<p>愿新的API能让大家的应用更加美观，have fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈Objective-C block的实现]]></title>
    <link href="http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/"/>
    <updated>2013-07-28T10:42:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p><a href="http://blog.parse.com/2013/02/05/objective-c-blocks-quiz/">这里</a>有关于block的5道测试题，建议你阅读本文之前先做一下测试。</p>

<p>先介绍一下什么是闭包。在wikipedia上，<a href="http://en.wikipedia.org/wiki/Closure_(computer_science">闭包的定义</a>)是:</p>

<p><blockquote><p>In programming languages, a closure is a function or reference to a function together with a referencing environment—a table storing a reference to each of the non-local variables (also called free variables or upvalues) of that function.</p></blockquote></p>

<p>翻译过来，闭包是一个函数（或指向函数的指针），再加上该函数执行的外部的上下文变量（有时候也称作自由变量）。</p>

<p>block实际上就是Objective-C语言对于闭包的实现。
block配合上dispatch_queue，可以方便地实现简单的多线程编程和异步编程，关于这个，我之前写过一篇文章介绍：<a href="http://blog.devtang.com/blog/2012/02/22/use-gcd/">《使用GCD》</a>。</p>

<p>本文主要介绍Objective-C语言的block在编译器中的实现方式。主要包括：</p>

<ol>
<li>block的内部实现数据结构介绍</li>
<li>block的三种类型及其相关的内存管理方式</li>
<li>block如何通过capture变量来达到访问函数外的变量</li>
</ol>


<!-- more -->


<h2>实现方式</h2>

<h3>数据结构定义</h3>

<p>block的数据结构定义如下（图片来自<a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/">这里</a>)：</p>

<p><img src="/images/block-struct.jpg"></p>

<p>对应的结构体定义如下：</p>

<p>``` objc
struct Block_descriptor {</p>

<pre><code>unsigned long int reserved;
unsigned long int size;
void (*copy)(void *dst, void *src);
void (*dispose)(void *);
</code></pre>

<p>};</p>

<p>struct Block_layout {</p>

<pre><code>void *isa;
int flags;
int reserved;
void (*invoke)(void *, ...);
struct Block_descriptor *descriptor;
/* Imported variables. */
</code></pre>

<p>};
```</p>

<p>通过该图，我们可以知道，一个block实例实际上由6部分构成：</p>

<ol>
<li>isa指针，所有对象都有该指针，用于实现对象相关的功能。</li>
<li>flags，用于按bit位表示一些block的附加信息，本文后面介绍block copy的实现代码可以看到对该变量的使用。</li>
<li>reserved，保留变量。</li>
<li>invoke，函数指针，指向具体的block实现的函数调用地址。</li>
<li>descriptor， 表示该block的附加描述信息，主要是size大小，以及copy和dispose函数的指针。</li>
<li>variables，capture过来的变量，block能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。</li>
</ol>


<p>该数据结构和后面的clang分析出来的结构实际是一样的，不过仅是结构体的嵌套方式不一样。但这一点我一开始没有想明白，所以也给大家解释一下，如下2个结构体SampleA和SampleB在内存上是完全一样的，原因是结构体本身并不带有任何额外的附加信息。</p>

<p>``` c
struct SampleA {</p>

<pre><code>int a;
int b;
int c;
</code></pre>

<p>};</p>

<p>struct SampleB {</p>

<pre><code>int a;
struct Part1 {
    int b;
};
struct Part2 {
    int c;
};
</code></pre>

<p>};</p>

<p>```</p>

<p>在Objective-C语言中，一共有3种类型的block：</p>

<ol>
<li>_NSConcreteGlobalBlock 全局的静态block，不会访问任何外部变量。</li>
<li>_NSConcreteStackBlock  保存在栈中的block，当函数返回时会被销毁。</li>
<li>_NSConcreteMallocBlock 保存在堆中的block，当引用计数为0时会被销毁。</li>
</ol>


<p>我们在下面会分别来查看它们各自的实现方式上的差别。</p>

<h3>研究工具：clang</h3>

<p>为了研究编译器是如何实现block的，我们需要使用clang。clang提供一个命令，可以将Objetive-C的源码改写成c语言的，借此可以研究block具体的源码实现方式。该命令是</p>

<p><code>c
clang -rewrite-objc block.c
</code></p>

<h3>NSConcreteGlobalBlock 类型的block的实现</h3>

<p>我们先新建一个名为block1.c的源文件：</p>

<p>``` objc</p>

<h1>include &lt;stdio.h></h1>

<p>int main()
{</p>

<pre><code>^{ printf("Hello, World!\n"); } ();
return 0;
</code></pre>

<p>}</p>

<p>```</p>

<p>然后在命令行中输入<code>clang -rewrite-objc block1.c</code>即可在目录中看到clang输出了一个名为block1.cpp的文件。该文件就是block在c语言实现，我将block1.cpp中一些无关的代码去掉，将关键代码引用如下：</p>

<p>``` objc
struct __block_impl {</p>

<pre><code>void *isa;
int Flags;
int Reserved;
void *FuncPtr;
</code></pre>

<p>};</p>

<p>struct __main_block_impl_0 {</p>

<pre><code>struct __block_impl impl;
struct __main_block_desc_0* Desc;
__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
}
</code></pre>

<p>};
static void <strong>main_block_func_0(struct </strong>main_block_impl_0 *__cself) {</p>

<pre><code>printf("Hello, World!\n");
</code></pre>

<p>}</p>

<p>static struct __main_block_desc_0 {</p>

<pre><code>size_t reserved;
size_t Block_size;
</code></pre>

<p>} <strong>main_block_desc_0_DATA = { 0, sizeof(struct </strong>main_block_impl_0) };</p>

<p>int main()
{</p>

<pre><code>(void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA) ();
return 0;
</code></pre>

<p>}</p>

<p>```</p>

<p>下面我们就具体看一下是如何实现的。__main_block_impl_0就是该block的实现，从中我们可以看出：</p>

<ol>
<li>一个block实际是一个对象，它主要由一个 isa 和 一个 impl 和 一个descriptor组成。</li>
<li><del>在本例中，isa指向 _NSConcreteGlobalBlock， 主要是为了实现对象的所有特性，在此我们就不展开讨论了。</del></li>
<li>由于clang改写的具体实现方式和LLVM不太一样，并且这里没有开启ARC。所以这里我们看到isa指向的还是<code>_NSConcreteStackBlock</code>。但在LLVM的实现中，开启ARC时，block应该是_NSConcreteGlobalBlock类型，具体可以看<a href="http://blog.parse.com/2013/02/05/objective-c-blocks-quiz/">《objective-c-blocks-quiz》</a>第二题的解释。</li>
<li>impl是实际的函数指针，本例中，它指向__main_block_func_0。这里的impl相当于之前提到的invoke变量，只是clang编译器对变量的命名不一样而已。</li>
<li>descriptor是用于描述当前这个block的附加信息的，包括结构体的大小，需要capture和dispose的变量列表等。结构体大小需要保存是因为，每个block因为会capture一些变量，这些变量会加到__main_block_impl_0这个结构体中，使其体积变大。在该例子中我们还看不到相关capture的代码，后面将会看到。</li>
</ol>


<h3>NSConcreteStackBlock 类型的block的实现</h3>

<p>我们另外新建一个名为block2.c的文件，输入以下内容：</p>

<p>``` objc</p>

<h1>include &lt;stdio.h></h1>

<p>int main() {</p>

<pre><code>int a = 100;
void (^block2)(void) = ^{
    printf("%d\n", a);
};
block2();

return 0;
</code></pre>

<p>}
```</p>

<p>用之前提到的clang工具，转换后的关键代码如下：</p>

<p>``` c
struct __main_block_impl_0 {</p>

<pre><code>struct __block_impl impl;
struct __main_block_desc_0* Desc;
int a;
__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
}
</code></pre>

<p>};
static void <strong>main_block_func_0(struct </strong>main_block_impl_0 *__cself) {</p>

<pre><code>int a = __cself-&gt;a; // bound by copy
printf("%d\n", a);
</code></pre>

<p>}</p>

<p>static struct __main_block_desc_0 {</p>

<pre><code>size_t reserved;
size_t Block_size;
</code></pre>

<p>} <strong>main_block_desc_0_DATA = { 0, sizeof(struct </strong>main_block_impl_0)};</p>

<p>int main()
{</p>

<pre><code>int a = 100;
void (*block2)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a);
((void (*)(__block_impl *))((__block_impl *)block2)-&gt;FuncPtr)((__block_impl *)block2);

return 0;
</code></pre>

<p>}
```</p>

<p>在本例中，我们可以看到：</p>

<ol>
<li>本例中，isa指向_NSConcreteStackBlock，说明这是一个分配在栈上的实例。</li>
<li><strong>main_block_impl_0 中增加了一个变量a，在block中引用的变量a实际是在申明block时，被复制到</strong>main_block_impl_0结构体中的那个变量a。因为这样，我们就能理解，在block内部修改变量a的内容，不会影响外部的实际变量a。</li>
<li><strong>main_block_impl_0 中由于增加了一个变量a，所以结构体的大小变大了，该结构体大小被写在了</strong>main_block_desc_0中。</li>
</ol>


<p>我们修改上面的源码，在变量前面增加__block关键字：</p>

<p>``` c</p>

<h1>include &lt;stdio.h></h1>

<p>int main()
{</p>

<pre><code>__block int i = 1024;
void (^block1)(void) = ^{
    printf("%d\n", i);
    i = 1023;
};
block1();
return 0;
</code></pre>

<p>}
```</p>

<p>生成的关键代码如下，可以看到，差异相当大：</p>

<p>``` c</p>

<p>struct __Block_byref_i_0 {</p>

<pre><code>void *__isa;
__Block_byref_i_0 *__forwarding;
int __flags;
int __size;
int i;
</code></pre>

<p>};</p>

<p>struct __main_block_impl_0 {</p>

<pre><code>struct __block_impl impl;
struct __main_block_desc_0* Desc;
__Block_byref_i_0 *i; // by ref
__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
}
</code></pre>

<p>};
static void <strong>main_block_func_0(struct </strong>main_block_impl_0 *__cself) {</p>

<pre><code>__Block_byref_i_0 *i = __cself-&gt;i; // bound by ref

printf("%d\n", (i-&gt;__forwarding-&gt;i));
(i-&gt;__forwarding-&gt;i) = 1023;
</code></pre>

<p>}</p>

<p>static void <strong>main_block_copy_0(struct </strong>main_block_impl_0<em>dst, struct __main_block_impl_0</em>src) {_Block_object_assign((void<em>)&amp;dst->i, (void</em>)src->i, 8/<em>BLOCK_FIELD_IS_BYREF</em>/);}</p>

<p>static void <strong>main_block_dispose_0(struct </strong>main_block_impl_0<em>src) {_Block_object_dispose((void</em>)src->i, 8/<em>BLOCK_FIELD_IS_BYREF</em>/);}</p>

<p>static struct __main_block_desc_0 {</p>

<pre><code>size_t reserved;
size_t Block_size;
void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
void (*dispose)(struct __main_block_impl_0*);
</code></pre>

<p>} <strong>main_block_desc_0_DATA = { 0, sizeof(struct </strong>main_block_impl_0), <strong>main_block_copy_0, </strong>main_block_dispose_0};</p>

<p>int main()
{</p>

<pre><code>__attribute__((__blocks__(byref))) __Block_byref_i_0 i = {(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 1024};
void (*block1)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344);
((void (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);
return 0;
</code></pre>

<p>}
```</p>

<p>从代码中我们可以看到：</p>

<ol>
<li>源码中增加一个名为__Block_byref_i_0 的结构体，用来保存我们要capture并且修改的变量i。</li>
<li><strong>main_block_impl_0 中引用的是</strong>Block_byref_i_0的结构体指针，这样就可以达到修改外部变量的作用。</li>
<li>__Block_byref_i_0结构体中带有isa，说明它也是一个对象。</li>
<li>我们需要负责<strong>Block_byref_i_0结构体相关的内存管理，所以</strong>main_block_desc_0中增加了copy和dispose函数指针，对于在调用前后修改相应变量的引用计数。</li>
</ol>


<h2>NSConcreteMallocBlock 类型的block的实现</h2>

<p>NSConcreteMallocBlock类型的block通常不会在源码中直接出现，因为默认它是当一个block被copy的时候，才会将这个block复制到堆中。以下是一个block被copy时的示例代码(来自<a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/">这里</a>)，可以看到，在第8步，目标的block类型被修改为_NSConcreteMallocBlock。</p>

<p>``` objc
static void <em>_Block_copy_internal(const void </em>arg, const int flags) {</p>

<pre><code>struct Block_layout *aBlock;
const bool wantsOne = (WANTS_ONE &amp; flags) == WANTS_ONE;

// 1
if (!arg) return NULL;

// 2
aBlock = (struct Block_layout *)arg;

// 3
if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) {
    // latches on high
    latching_incr_int(&amp;aBlock-&gt;flags);
    return aBlock;
}

// 4
else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) {
    return aBlock;
}

// 5
struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);
if (!result) return (void *)0;

// 6
memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first

// 7
result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
result-&gt;flags |= BLOCK_NEEDS_FREE | 1;

// 8
result-&gt;isa = _NSConcreteMallocBlock;

// 9
if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
    (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup
}

return result;
</code></pre>

<p>}
```</p>

<h3>变量的复制</h3>

<p>对于block外的变量引用，block默认是将其复制到其数据结构中来实现访问的，如下图所示（图片来自<a href="http://rypress.com/tutorials/objective-c/blocks.html">这里</a>）：</p>

<p><img src="/images/block-capture-1.jpg"></p>

<p>对于用__block修饰的外部变量引用，block是复制其引用地址来实现访问的，如下图所示（图片来自<a href="http://rypress.com/tutorials/objective-c/blocks.html">这里</a>）：</p>

<p><img src="/images/block-capture-2.jpg"></p>

<h3>LLVM源码</h3>

<p>在LLVM开源的关于<a href="https://llvm.org/svn/llvm-project/compiler-rt/trunk/BlocksRuntime/Block_private.h">block的实现源码</a>，其内容也和我们用clang改写得到的内容相似，印证了我们对于block内部数据结构的推测。</p>

<h3>ARC对block类型的影响</h3>

<p>在ARC开启的情况下，将只会有 NSConcreteGlobalBlock和 NSConcreteMallocBlock类型的block。</p>

<p>原本的NSConcreteStackBlock的block会被NSConcreteMallocBlock类型的block替代。证明方式是以下代码在XCode中，会输出 <code>&lt;__NSMallocBlock__: 0x100109960&gt;</code>。在苹果的<a href="http://developer.apple.com/library/ios/#releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">官方文档</a>中也提到，当把栈中的block返回时，不需要调用copy方法了。</p>

<p>``` objc</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>int main(int argc, const char * argv[])
{</p>

<pre><code>@autoreleasepool {
    int i = 1024;
    void (^block1)(void) = ^{
        printf("%d\n", i);
    };
    block1();
    NSLog(@"%@", block1);
}
return 0;
</code></pre>

<p>}</p>

<p>```</p>

<p>我个人认为这么做的原因是，由于ARC已经能很好地处理对象的生命周期的管理，这样所有对象都放到堆上管理，对于编译器实现来说，会比较方便。</p>

<h3>参考链接</h3>

<p>希望本文能加深你对于block的理解。我在学习中，查阅了以下文章，一并分享给大家。祝大家玩得开心～</p>

<ul>
<li><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-1/">A look inside blocks: Episode 1</a></li>
<li><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-2/">A look inside blocks: Episode 2</a></li>
<li><a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/">A look inside blocks: Episode 3</a></li>
<li><a href="http://www.cnblogs.com/biosli/archive/2013/05/29/iOS_Objective-C_Block.html">对Objective-C中Block的追探</a></li>
<li><a href="https://llvm.org/svn/llvm-project/compiler-rt/trunk/BlocksRuntime/Block_private.h">LLVM中block实现源码</a></li>
<li><a href="http://blog.parse.com/2013/02/05/objective-c-blocks-quiz/">objective-c-blocks-quiz</a></li>
<li><a href="http://rypress.com/tutorials/objective-c/blocks.html">Blocks</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Crashlytics来保存应用崩溃信息]]></title>
    <link href="http://blog.devtang.com/blog/2013/07/24/use-crashlytics/"/>
    <updated>2013-07-24T20:56:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/07/24/use-crashlytics</id>
    <content type="html"><![CDATA[<p><img src="/images/crashlytics-logo.jpg"></p>

<p>本文首发于InfoQ，版权归InfoQ所有，转载请保留<a href="http://www.infoq.com/cn/articles/crashlytics-crash-statistics-tools">原文链接</a>。</p>

<h2>简介</h2>

<p><a href="http://try.crashlytics.com/">Crashlytic</a> 成立于2011年，是专门为移动应用开者发提供的保存和分析应用崩溃信息的工具。Crashlytics的使用者包括：支付工具Paypal, 点评应用Yelp, 照片分享应用Path, 团购应用GroupOn等移动应用。</p>

<p>2013年1月，Crashlytics<a href="http://www.crashlytics.com/blog/crashlytics-is-joining-forces-with-twitter/">被Twitter收购</a>，成为又一个成功的创业产品。被收购之后，由于没有了创业公司的不稳定因素，我们更有理由使用它来分析应用崩溃信息。</p>

<!-- more -->


<p>使用Crashlytics的好处有：</p>

<p>1、Crashlytics不会漏掉任何应用崩溃信息。拿我的应用举例来说，在iTunes Connect的后台查看不到任何崩溃信息。但是用户确实会通过微博或者客服电话反馈应用崩溃的情况。而这些在Crashlytics中都可以统计到。如下截图分别显示了我的某应用在苹果iTunes Connect后台和Crashlytics中的差别：</p>

<p><img src="/images/crashlytics-vs-itunes-1.jpg">
<img src="/images/crashlytics-vs-itunes-2.jpg"></p>

<p>2、Crashlytics可以象Bug管理工具那样，管理这些崩溃日志。例如：Crashlytics会根据每种类型的Crash的出现频率以及影响的用户量来自动设置优先级。对于每种类型的Crash，Crashlytics除了会像一般的工具提供Call Stack外，还会显示更多相关的有助于诊断的信息例如设备是否越狱，当时的内存量，当时的iOS版本等。对于修复掉的Crash日志，可以在Crashlytics的后台将其关掉。下图所示的是一个我的早期应用的崩溃记录，在我修复后，我将其更新为已修复状态。</p>

<p><img src="/images/crashlytics-close-issue.jpg"></p>

<p>3、Crashlytics可以每天和每周将崩溃信息汇总发到你的邮箱，所有信息一目了然。</p>

<p>下面我就给大家介绍如何使用Crashlytics。</p>

<h2>使用介绍</h2>

<h3>申请帐号</h3>

<p>Crashlytics的服务是免费提供的，但是并不能直接注册使用，需要先申请，打开<a href="http://try.crashlytics.com/">Crashlytic的官网</a> ，输入自己的邮箱申请使用。如下图所示：</p>

<p><img src="/images/crashlytics-1.jpg"></p>

<p>提交完邮箱之后，你的申请会放在Crashlytics的申请队列中，网页跳转到如下界面。在这个界面的右侧，你可以提供更多有效信息来让Crashlytics优先处理你的申请，建议大家都填上更多自己的信息。</p>

<p><img src="/images/crashlytics-2.jpg"></p>

<p>如果顺利，通常1-2天左右，你就会收到Crashlytics发来的申请通过邮件，如下图所示，通过邮件链接跳转到注册界面，填写密码即可完成注册。</p>

<p><img src="/images/crashlytics-3.jpg"></p>

<h3>设置工程</h3>

<p>在使用Crashlytics前需要对原有的XCode工程进行配置，在这一点上，Crashlytics做得比其它任何我见过的SDK提供商都体贴。因为Crashlytics专门做了一个Mac端的App来帮助你进行配置，所以，在配置前你先需要去<a href="https://www.crashlytics.com/downloads/xcode">这里</a>下载该应用。</p>

<p>应用下载后，运行该应用并登录帐号。然后选择应用中的"New App"按钮，然后选择自己要增加Crashlytics的工程，然后Crashlytics的应用会提示你为工程增加一个Run Script，如果你不知道如何添加，这里有一个<a href="http://www.runscriptbuildphase.com/?utm_source=desktopapp&amp;utm_medium=setup&amp;utm_campaign=mac">帮助的文档</a>。添加好之后的工程截图如下所示</p>

<p><img src="/images/crashlytics-4.jpg"></p>

<p>接着，Crashlytics的本地应用会提示你将Crashlytics相关的framework拖到工程中。如下所示：</p>

<p><img src="/images/crashlytics-5.jpg"></p>

<p>按照提示做完之后，就到了最后一步了，在<code>AppDelegate</code>的<code>didFinishLaunchingWithOptions</code>方法中加入如下代码：</p>

<p>``` objc</p>

<h1>import &lt;Crashlytics/Crashlytics.h></h1>

<ul>
<li>(BOOL)application:(UIApplication <em>)application
  didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions {
 [Crashlytics startWithAPIKey:@"your identify code"];
}
```</li>
</ul>


<p>之后，运行一下程序，Crashlytics就会检测到你设置成功。如果你感兴趣，可以自己手工触发一个崩溃记录，看Crashlytics能否帮你收集到。使用如下代码即可</p>

<p><code>objc
[[Crashlytics sharedInstance] crash];
</code></p>

<p>如果你想测试一个Exception导致的崩溃，可以使用如下代码：</p>

<p><code>objc
[NSObject doesNotRecognizeSelector];
[arrayWithOnlyTwoElements objectAtIndex:3];
</code></p>

<p>应用对外发布后，就可以在Crashlytics后台查看和修改相关的记录。另外，Crashlytics还支持将数据导入到其它项目管理工具（例如Redmine或Jira）如下所示，配置都非常简单。</p>

<p><img src="/images/crashlytics-6.jpg"></p>

<h2>实现原理和使用体会</h2>

<h3>实现原理</h3>

<p>在原理上，Crashlytics的通过以下2步完成崩溃日志的上传和分析：</p>

<ol>
<li>提供应用SDK，你需要在应用启动时调用其SDK来设置你的应用。SDK会集成到你的应用中，完成Crash信息的收集和上传。</li>
<li>修改工程的编译配置，加入一段代码，在你每次工程编译完成后，上传该工程对应的dSYM文件。研究过手工分析Crash日志的同学应该知道，只有通过该文件，才能将Crash日志还原成可读的Call Stack信息。</li>
</ol>


<h3>使用体会</h3>

<p>为了更加方便开发者设置相应的工程，Crashlytics提供了mac端的应用程序，帮助你检测相关工程是否正确设置并且提供相应的帮助信息。后来我还发现，该程序还会自动帮你升级Crashlytics的SDK文件。虽然这一点很体贴，但是我个人觉得还是不太友好。因为毕竟修改SDK会影响应用编译后的内部逻辑，在没有任何通知的情况下升级，我都无法确定Crashlytics有没有干坏事。不过国外的服务，特别是象Twitter这种相对较大知名度公司提供的服务要有节操得多，所以在这一点上我还是比较放心的。</p>

<p>使用Crashlytics可以让你摆脱管理应用崩溃记录的烦恼。并且帮助你找出应用的一些重大隐藏性Bug。例如我之前写的一个应用就过一个缓存过期的问题，只有当缓存过期时才会触发这个Bug，这样的问题在测试人员那边很难触发，因为他们不可能了解你的应用内部实现细节。通过Crashlytics，使我清楚了解到应用Crash的数量和位置，结合自己的开发经验，就很容易找到问题所在了。</p>

<p>值得一提的是，Crashlytics本身的<a href="http://support.crashlytics.com/knowledgebase/topics/14721-crashlytics-sdk-for-ios">官方文档</a>也非常健全，如果你在使用中遇到任何问题，也可以上去查看详细的文档。</p>

<p>愿Crashlytics能让大家的应用都更加健壮～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分析支付宝客户端的插件机制]]></title>
    <link href="http://blog.devtang.com/blog/2013/06/23/alipay-plugin-mechanism/"/>
    <updated>2013-06-23T12:39:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/06/23/alipay-plugin-mechanism</id>
    <content type="html"><![CDATA[<p><img src="/images/alipay-plugin-1.jpg"></p>

<h2>前言</h2>

<p>因为开了iOSDevTips的微信公共账号，老收到各种iOS开发的问题，前两天收到一个问题的内容是：</p>

<pre><code>请问像支付宝钱包那样可以在应用里安装自己的应用，是已经在应用里写了逻辑，还是可以向应用里发送代码?
</code></pre>

<p>我觉得这个问题挺有意思的，估计大家都感兴趣，所以今天就抽空研究了一下，将支付宝客户端的插件机制具体实现方式介绍给大家。</p>

<p>先介绍一下该插件机制，如上图所示，支付宝客户端在安装后，对于像“彩票”、“爱心捐赠”这类功能，需要再点击安装一次，然后才可以使用。有些时候该插件功能进行了升级，需要点击升级才可以继续使用。插件的方式有利于软件动态增加新的功能或升级功能，而不用再一次向AppStore提交审核。另外，由于用户不需要的插件可以不用安装，也缩小了应用本身的体积大小，节省了下载流量。</p>

<!-- more -->


<h2>分析过程</h2>

<h3>截取网络请求</h3>

<p>分析第一步，截取网络请求。截取网络请求可以查看当用户点击“彩票”进行安装的时候，客户端到底做了什么事情。使用Charles的代理设置功能，启动一个http代理，然后在iPhone上设置连接此代理，则可以看到，当点击“彩票”插件时，客户端下载了一个名为 10000011.amr的文件。如下图所示：</p>

<p><img src="/images/alipay-plugin-2.jpg"></p>

<h3>下载插件文件</h3>

<p>尝试用wget将文件下载下来，发现其没有验证cookie，下载成功，命令如下：</p>

<p><code>bash
wget http://download.alipay.com/mobilecsprod/alipay.mobile/20130601021432806/xlarge/10000011.amr
</code></p>

<p>amr本意表示是一个音频文件，明显不对，尝试将其后缀名改成zip，成功将其解压。用itools连接上支付宝的客户端，同样能看到客户端将其下载后，也是解压到document目录下的。解压后的内容与应用内新增加的内容一致，如图所示：</p>

<p><img src="/images/alipay-plugin-3.jpg"></p>

<h3>分析文件内容</h3>

<p>大概浏览了一下解压后的文件，主要包括html、css和js文件。可见支付宝的插件机器是通过UIWebView来展示内容的方式来实现的，那为什么要先下载安装这些内容而不通过UIWebView实时下载html呢？这主要应该是为了节省相应的流量。我看了一下，10000011.amr文件整个有将近1M大小，如果不通过插件机制预先下载，则只能依赖系统对于UIWebView的缓存来节省流量，这相对来说没有前者靠谱。</p>

<p>另外，使用基于UIWebView的方式来展示插件，也有利于代码的复用。因为这些逻辑都是用js来写的，可以同样应用于Android平台，在Config.js文件中，明显可以看到对于各类平台的判断逻辑。如下图所示：</p>

<p><img src="/images/alipay-plugin-4.jpg"></p>

<p>另外，/www/demo/index-alipay-native.html 文件即该插件的首页，用浏览器打开就可以看到和手机端一样的内容。如下载图所示（左半边是手机上的应用截图，右半边是浏览器打开该html文件的截图）：</p>

<p><img src="/images/alipay-plugin-5.jpg"></p>

<h3>插件的网络通讯</h3>

<p>接下来感兴趣的是该插件是如何完成和支付宝后台的网络通讯的。可以想到有两种可能的方式：</p>

<ol>
<li>直接和支付宝后台通讯</li>
<li>和Native端通讯，然后Native端和服务器通讯。</li>
</ol>


<p>要验证这个需要读该插件的js源代码，整个js源码逻辑还是比较干净的，主要用了玉伯写的<a href="http://seajs.org/docs/">seajs</a>做模块化加载，<a href="http://backbonejs.org/">backbone.js</a>是一个前端的MVC框架，<a href="http://zeptojs.com/">zepto.js</a>是一个更适合于移动端使用的"JQuery"。</p>

<p>大概扫了一下，感觉更可能是用的方法一：直接和支付宝后台通讯, 因为Config.js中都明确将网络通讯的地址写下来了。另一个证据是，利用下面的脚本扫描整个js源码，只能在backbone中搜到对于iframe的使用。而在iOS开发中，如果js端和native端要通讯，是需要用到iframe的，详细原理可以参见我的另一篇文章<a href="http://blog.devtang.com/blog/2012/03/24/talk-about-uiwebview-and-phonegap/">《关于UIWebView和PhoneGap的总结》</a>。不过我不能完全确认，因为我还没有找到相应控制页面切换和跳转的js代码，如果你找到了，麻烦告诉我。</p>

<p><code>bash
find . -type f -name "*.js" | xargs grep "iframe"
</code></p>

<h3>交易的安全</h3>

<p>用Charles可以截取到，当有网络交易时，应用会另外启动一个https的安全链接，完成整个交易过程的加密。如下图所示：</p>

<p><img src="/images/alipay-plugin-6.jpg"></p>

<h2>总结</h2>

<p>支付宝的插件机制整体上就是通过html和javascript方式实现的，主要的好处是：</p>

<ol>
<li>跨平台(可以同时用在iOS和Android客户端）</li>
<li>省流量（不需要的插件不用下载，插件本地缓存长期存在不会过期，自己管理插件更新逻辑）</li>
<li>更新方便（不用每次提交AppStore审核）</li>
</ol>


<p>坏处如果非要说有的话，就是用javascript写iOS界面，无法提供非常炫的UI交互以及利用到iOS的所有平台特性。不过象支付宝这种工具类应用，也不需要很复杂的UI交互效果。</p>

<p>另外教大家一个小技巧，如果你不确定某个页面是不是UIWebView做的，直接在那个页面长按，如果弹出"拷贝，定义，学习"这种菜单，那就是确定无疑是UIWebView的界面了。如下图所示：</p>

<p><img src="/images/ios-menu-2.jpg"></p>

<h2>相关工具</h2>

<p>欢迎关注我的技术微博 <a href="http://weibo.com/tangqiaoboy">@唐巧_boy</a> 和微信公共账号 <a href="http://chuansong.me/account/iosDevTips">iOSDevTips</a> ，每天收获一些关于iOS开发的学习资料和技巧心得。</p>

<p>我在研究时使用了<a href="http://www.charlesproxy.com/">Charles</a>来截获支付宝客户端的网络请求，用<a href="http://itools.hk/">iTools</a>来查看支付宝客户端的本地内容。如果你想自行验证本文内容，请先下载上述工具。在此就不额外介绍它们的使用了。</p>

<h2>后记（2013-7-7）</h2>

<ol>
<li><p>在完成上文后，Allen在他的博客上先后分享了两篇更深入分析的文章<a href="http://imallen.com/blog/2013/06/26/inside-alipay-plugin.html">《浅析支付宝钱包插件》</a> 和 <a href="http://imallen.com/blog/2013/07/06/about-alipay-plugin-and-phonegap.html">《再谈支付宝钱包插件和说好的 Demo》</a>。 这两篇文章都比本文深入得多，值得大家阅读。</p></li>
<li><p>写完上文，居然收到了来自支付宝卫朴（花名）的工作邀请。不过我现在创业正在努力当中，所以我拒绝了邀请。看来这也是一种找工作的办法啊，比投简历管用，呵呵。</p></li>
<li><p>从一些朋友那儿了解到，支付宝因为本文而会在以后的版本中加强安全性，至少不会像现在这样，所有逻辑都在写在javascript中，并且还带有注释，这也是我希望看到的结果。愿支付宝越做越好。</p></li>
</ol>

]]></content>
  </entry>
  
</feed>
