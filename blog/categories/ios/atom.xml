<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 唐巧的技术博客]]></title>
  <link href="http://blog.devtang.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.devtang.com/"/>
  <updated>2012-12-23T20:01:49+08:00</updated>
  <id>http://blog.devtang.com/</id>
  <author>
    <name><![CDATA[唐巧]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在iOS中使用ZXing库]]></title>
    <link href="http://blog.devtang.com/blog/2012/12/23/use-zxing-library/"/>
    <updated>2012-12-23T17:03:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/12/23/use-zxing-library</id>
    <content type="html"><![CDATA[<p><img src="/images/zxing-icon.png"></p>

<h2>前言</h2>

<p><a href="https://code.google.com/p/zxing/">ZXing</a>(<a href="https://github.com/zxing/zxing">Github镜像地址</a>)是一个开源的条码生成和扫描库（开源协议为<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache2.0</a>)。它不但支持众多的条码格式，而且有各种语言的实现版本，它支持的语言包括：Java, C++, C#, Objective-C, ActionScript和Ruby。</p>

<p>我上周在iOS项目开发中使用了ZXing的扫描二维码功能。在此总结一下如何将ZXing集成到已有的iOS工程中，分享给大家。</p>

<!-- more -->


<h2>集成步骤</h2>

<p>首先去Google Code或Github将ZXing的代码下载下来，整个工程比较大，我们只需要其中涉及iOS的部分，所以最好做一些裁剪。简单来说，我们只需要保留cpp和iphone这2个文件夹，其余的全部删掉。如下图所示：</p>

<p><img src="/images/zxing-step-1.png"></p>

<p>接着我们继续裁剪，对于cpp这个目录，只保留cpp/core/src/zxing下面的内容，其余内容也可以删掉了。但是整个目录结构必须保持原样。裁剪完后，整个目录结构如下所示：</p>

<p><img src="/images/zxing-step-2.png"></p>

<p>接下来，我们把裁剪后的zxing目录整个移动到我们的iOS项目的目录下，并且把上图中可以看到的ZXingWidget.xcodeproj文件拖动到我们的iOS工程中。</p>

<p>下一步，我们需要设置ZXing项目和我们原本的iOS项目之间的依赖关系。在我们的iOS项目的设置中，点击build phases tab，然后增加 Target Dependencies 和 Link binary，并且增加这些framework依赖：</p>

<pre><code>a. AVFoundation
b. AudioToolbox
c. CoreVideo
d. CoreMedia
e. libiconv
f. AddressBook
g. AddressBookUI
</code></pre>

<p>完成之后如下图所示：</p>

<p><img src="/images/zxing-step-3.png"></p>

<p>最后一步，在设置中增加如下2个header search path:</p>

<ul>
<li>./zxing/iphone/ZXingWidget/Classes</li>
<li>./zxing/cpp/core/src</li>
</ul>


<p>需要注意的是，第一个path要设置成循环查找子目录，而第二个不循环查找，如下图所示：</p>

<p><img src="/images/zxing-step-4.png"></p>

<p>恭喜你，完成这步之后，你就已经完成ZXing库的集成了。下面谈谈如何使用ZXing库来做二维码识别。</p>

<h2>二维码识别</h2>

<p>ZXing的iOS版本提供2种方法来做二维码识别功能，第一种方法比较简单，第二种方法比较复杂。我在做Demo时使用了第一种方法，做真正项目开发的时候使用了第二种方法，所以都给大家介绍一下。</p>

<h3>使用方法一</h3>

<p>ZXing直接提供了一个扫描二维码的View Controller，即ZXingWidgetController。在需要使用的界面代码中，加入文件依赖：</p>

<p>``` objc</p>

<h1>import &lt;ZXingWidgetController.h></h1>

<h1>import &lt;QRCodeReader.h></h1>

<p><code>
然后在需要扫描的时候，调用如下代码即可：
</code> objc
- (IBAction)scanPressed:(id)sender {
  ZXingWidgetController <em>widController = [[ZXingWidgetController alloc] initWithDelegate:self showCancel:YES OneDMode:NO];
  NSMutableSet </em>readers = [[NSMutableSet alloc ] init];
  QRCodeReader* qrcodeReader = [[QRCodeReader alloc] init];
  [readers addObject:qrcodeReader];
  [qrcodeReader release];
  widController.readers = readers;
  [readers release];
  [self presentModalViewController:widController animated:YES];
  [widController release];
}
```</p>

<p>在ZXing扫描有结果时，会调用如下回调函数：</p>

<p>``` objc</p>

<p>@protocol ZXingDelegate
- (void)zxingController:(ZXingWidgetController<em>)controller didScanResult:(NSString </em>)result;
- (void)zxingControllerDidCancel:(ZXingWidgetController*)controller;
@end</p>

<p>```</p>

<h3>使用方法二</h3>

<p>方法二与方法一的区别就相当于AVFoundation和UIImagePickerController的区别一样。简单来说，就是使用方法二比方法一更加麻烦，但是获得的可定制性更高。</p>

<p>使用方法二时，你需要自己用AVFoundation获得Camera返回的实时图象，然后转成UIImage，最后传给ZXing的Decoder类完成二维码的识别。由于使用AVFoundation涉及的代码略多，我写的示意代码如下：</p>

<p>``` objc</p>

<h1>import "Decoder.h"</h1>

<h1>import "TwoDDecoderResult.h"</h1>

<h1>import "QRCodeReader.h"</h1>

<ul>
<li>(void)viewDidLoad {
  // setup QR reader
  self.qrReader = [[NSMutableSet alloc ] init];
  QRCodeReader* qrcodeReader = [[QRCodeReader alloc] init];
  [self.qrReader addObject:qrcodeReader];
  self.scanningQR = NO;
  self.step = STEP_QR;
}</li>
</ul>


<p>// AVFoundation的回调函数
- (void)captureOutput:(AVCaptureOutput <em>)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection </em>)connection {</p>

<pre><code>// 第一步，将sampleBuffer转成UIImage
UIImage *image= [self getCaptureImage:sampleBuffer];
// 第二步，用Decoder识别图象
Decoder *d = [[Decoder alloc] init];
d.readers = self.qrReader;
d.delegate = self;
self.scanningQR = [d decodeImage:image] == YES ? NO : YES;
</code></pre>

<p>}
```</p>

<p>ZXing的Decoder类提供了以下回调函数获得识别结果：</p>

<p>``` objc
@protocol DecoderDelegate<NSObject>
@optional
- (void)decoder:(Decoder <em>)decoder willDecodeImage:(UIImage </em>)image usingSubset:(UIImage <em>)subset;
- (void)decoder:(Decoder </em>)decoder didDecodeImage:(UIImage <em>)image usingSubset:(UIImage </em>)subset withResult:(TwoDDecoderResult *)result {</p>

<pre><code>NSLog(@"result = %@", [result text]);
</code></pre>

<p>}
- (void)decoder:(Decoder <em>)decoder failedToDecodeImage:(UIImage </em>)image usingSubset:(UIImage <em>)subset reason:(NSString </em>)reason;
- (void)decoder:(Decoder *)decoder foundPossibleResultPoint:(CGPoint)point;</p>

<p>@end</p>

<p>```</p>

<h2>Trouble Shoot &amp; Tips</h2>

<p>我在使用中遇到了一些问题，主要是编译的问题。</p>

<ol>
<li>一个是找不到 <iostream> 头文件。解决方法：把用到ZXing的源文件扩展名由.m改成.mm。</li>
<li>报错：Undefined symbols for architecture armv7s，<a href="http://stackoverflow.com/questions/12968369/undefined-symbols-for-architecture-armv7-when-using-zxing-library-in-xcode-4-5">解决方法</a>：把ZXingWidget的一个build target参数："Build Active Architecture Only" 修改成 "NO".</li>
<li>报错：No such file or directory，出现该错误可能是你的Header Search Path写错了，或者就是你的zxing库的目录结构不是我上面强调的，好好检查一下吧。</li>
<li>如果你需要生成二维码做测试，推荐一个不错的在线生成二维码的网站：<a href="http://cli.im/">http://cli.im/</a></li>
</ol>


<h2>ZXing和OpenCV的兼容问题</h2>

<p>ZXing 2.1 和OpenCV 2.4.3的iOS库有一些兼容问题，他们对C++标准库的版本和编译器版本都有一些需求，造成满足一方了，另一方就编译不通过了。Stackoverflow上有人终于找到了一个让它们和平共处的方法，但是只适用于iOS5.0以上版本。正好我们的App只支持iOS5.0+，所以就搞定了。所以如果你也正好遇到这个问题，可以参考<a href="http://stackoverflow.com/questions/13498581/opencv-zxing-incompatibility-on-ios">这个贴子</a>。</p>

<p>希望本文对大家有用，Have Fun~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[StoryBoard--看上去很美]]></title>
    <link href="http://blog.devtang.com/blog/2012/12/15/do-not-use-storyboard/"/>
    <updated>2012-12-15T10:21:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/12/15/do-not-use-storyboard</id>
    <content type="html"><![CDATA[<h2>介绍</h2>

<p>StoryBoard是苹果在2011年的WWDC Session 309《Introducing Interface Builder Storyboarding》中介绍的Interface Builder的新功能。其基本想法是将原本的xib进行升级，引入一个容器用于管理多个xib文件，并且这个容器可以通过拖拽设置xib之间的界面跳转。而这个容器就是被苹果称做的StoryBoard。下图是一个Storyboard的截图。</p>

<p><img src="/images/enbrace-ios5-1.png"></p>

<!-- more -->


<h2>优点</h2>

<p>总体上来说，Storyboard有以下好处：</p>

<ol>
<li>你可以从storyboard中很方便地梳理出所有View Controller的界面间的调用关系。这一点对于新加入项目组的开发同事来说，比较友好。</li>
<li>使用Storyboard可以使用Table View Controller的Static Cell功能。对于开发一些Cell不多，但每个Cell都不一样的列表类设置界面会比较方便。</li>
<li>通过实现 - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender 方法，每个View Controller的跳转逻辑都聚集在一处，这方便我们统一管理界面跳转和传递数据。</li>
<li>Storyboard可以方便将一些常用功能模块化和复用。例如WWDC2011年介绍Storyboard的视频就将微博分享功能模块化成一个单独的Storyboard。我在开发App时，也将例如通过第三方注册登录模块做成一个单独的Storyboard，便于以后复用。</li>
</ol>


<h2>缺点</h2>

<p>我在新项目使用Storyboard时，却发现它只是看上去很美，真正用起来，却有很多问题，我发现的问题有：</p>

<ol>
<li>首先它和xib一样，对版本管理是灾难。因为是它实际上的多个xib的集合，所以更容易让多人编辑产生冲突。苹果对storyboard的设计也不好，基本上你只要打开，什么都不做，这个文件就会被更改，所以冲突几乎是不可避免的---除非你不打开，实在不小心打开看了，需要在提交前回退成服务器上的版本。</li>
<li>Storyboard提供的 Static cell特性只适合于UITableViewController的子类。我很多时候的用法是一个TableView嵌套在另一个UIView中，static cell就不能用了。</li>
<li>segue的概念对于开发来说并不省事，如果是用程序内部trigger一个segue，那么需要在另一个回调的地方设置dest view controller的参数信息。</li>
</ol>


<h2>总结</h2>

<p>我仔细比较权衡了一下优缺点，最主要的问题是我的版本管理在多人协作开发时将陷入灾难，而这是完全不能接受的。而最主要的好处就是，你可以在一个类似白板的地方“一揽众山小“一样了解所有界面之间的切换关系，但这个有那么重要吗？我自已其实很清楚跳转逻辑，这个只是对新同事了解项目代码时有帮助，那我花一点时间直接给他讲讲画画不就搞定的吗？为了这点好处而让版本管理无法使用，是完全不能接受的。</p>

<p>所以最终我决定放弃使用StoryBoard了，这个“看上去很美”的功能有着不可接受的缺陷。现在看来，它仅适用于做一些Demo的开发。苹果一直没有处理好这类可视化界面设计功能的版本管理，象xib文件，虽然是xml格式的，但如果多人编辑了，合并起来也会很麻烦。所以业界好多同行都不用xib,直接用纯代码来写界面，虽然稍慢一点儿，但是工程很干净，也基本没有了多人协作的版本冲突问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于IAP的破解]]></title>
    <link href="http://blog.devtang.com/blog/2012/12/09/iap-crack-issue/"/>
    <updated>2012-12-09T15:06:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/12/09/iap-crack-issue</id>
    <content type="html"><![CDATA[<h3>介绍</h3>

<p>大概在今年7月份，有俄罗斯黑客<a href="http://www.in-appstore.com/">破解</a>了苹果的应用内付费（In-App Purchases），设备在不越狱的情况下就可以免费获得来自苹果官网App Store里应用的收费道具。受影响的产品众多，包括著名的Angry Birds，切水果，Mega Jump, Pandora等。<a href="https://docs.google.com/spreadsheet/ccc?key=0AvSXyNTiqEXMdGRKZlN1Snl5S3h1Z1NsTTFYTlJPTUE#gid=0">这里</a>有一份受影响的著名的游戏应用列表。</p>

<p>正常的越狱行为还是比较复杂的，需要下载破解软件，并且操作进入DFU模式，所以大部分人并不能够方便地越狱。但该方案不需要越狱就可以破解应用内付费，给用户实施该行为提供了方便。</p>

<!-- more -->


<p>为了验证破解的有效性，我今天试了一下，确实能够直接绕开苹果的应用内付费就直接完成购买操作。而苹果也在它的官方文档上<a href="http://developer.apple.com/library/ios/#releasenotes/StoreKit/IAP_ReceiptValidation/_index.html">特别注明</a>了该漏洞的存在，截图如下：</p>

<p><img src="/images/iap-crack-issue.png"></p>

<p>从该文档中我们可以知道，iOS6以下的所有设备（包括越狱或非越狱设备），都会受到该漏洞的影响。</p>

<h3>攻击原理</h3>

<p>我们知道通常的IAP购买行为，从逻辑上就是设备向App Store发起一个购买操作，App Store在验证过用户的密码确认身份后，扣费并返回购买成功的凭证，整个网络操作是通过SSL加密的。</p>

<p>该IAP破解方法，是让设备误以为另一个网站就是AppStore，而向它通讯，而这个假AppStore返回一个假的购买成功的凭证，这样就欺骗设备完成了购买。整个欺骗使用的手段包括：</p>

<ol>
<li>用户给自己添加一个受信任的证书以完成SSL通讯的证书校验</li>
<li>设置一个伪DNS（域名解析服务）地址，把AppStore的域名指向假的地址。</li>
</ol>


<h3>应对措施</h3>

<p>现在看来，暂时有效的应对方法是，将该交易凭证上传到我们自己的服务器上，然后让我们自己的服务器与AppStore进行验证，以确认该凭证是否是伪造的，然后将验证结果返回给设备。苹果的官方网站上也是这么介绍的。这样做麻烦的地方是，对于那些游戏和工具类应用，增加了服务器开发和维护的开销。</p>

<p>但是就象苹果自己也意识到的那样（如下图），既然破解者可以欺骗设备来和AppStore通讯，那么同样破解者从原理上，也可以欺骗设备同我们自己的服务器通讯，到头来，设备本身无论如何是无法知道自己的信息的真实性的。</p>

<p><img src="/images/iap-crack-isuue-2.png"></p>

<p>对于这件事，我们只能期望于：因为我们的应用用户量不大，验证协议又不是通用的，所以破解者需要专门针对我们的通讯协议进行破解，这需要他本身有动力做这个事情，并且要花费他一些时间。所以可能他觉得做这个事情没什么挑战和意义，就不破解我们了。在这件事情上，“希望他不要破解”，好象也是我们唯一能做的事情。</p>

<p>乐观一点讲，AppStore上有上百万的应用，如果所有应用都采用服务器验证购买凭证，黑客一一针对破解，确实也太不可能了，所以这件事情还是很有必要的。另外随着iOS6的普及，该漏洞也将被修补掉，所以大家也不用过于悲观。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS应用内付费(IAP)开发步骤列表]]></title>
    <link href="http://blog.devtang.com/blog/2012/12/09/in-app-purchase-check-list/"/>
    <updated>2012-12-09T12:55:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/12/09/in-app-purchase-check-list</id>
    <content type="html"><![CDATA[<p>前两天和服务端同事一起，完成了应用内付费（以下简称IAP, In app purchase）的开发工作。步骤繁多，在此把开发步骤列表整理如下。因为只是步骤列表，所以并不含详细的说明教程，需要看教程的新手，可以看我附在最后的一些参考链接。</p>

<!-- more -->


<h3>配置Developer.apple.com</h3>

<p>登录到<a href="https://developer.apple.com/">Developer.apple.com</a>，然后进行以下步骤：</p>

<ol>
<li>为应用建立建立一个不带通配符的App ID</li>
<li>用该App ID生成和安装相应的Provisioning Profile文件。</li>
</ol>


<h3>配置iTunes Connect</h3>

<p>登录到<a href="https://itunesconnect.apple.com/">iTunes Connet</a>，然后进行以下步骤：</p>

<ol>
<li>用该App ID创建一个新的应用。</li>
<li><p>在该应用中，创建应用内付费项目，选择付费类型，通常可选的是可重复消费(Consumable)的或是永久有效(Non-Consumable)的2种，然后设置好价格和Product ID以及购买介绍和截图即可，这里的Product ID是需要记住的，后面开发的时候需要。如下图所示：
<img src="/images/iap-add-product-id.png"></p></li>
<li><p>添加一个用于在sandbox付费的测试用户，如下图所示。注意苹果对该测试用户的密码要求
和正式账号一样，必须是至少8位，并且同时包含数字和大小写字母：
<img src="/images/iap-adduser-1.png">
<img src="/images/iap-adduser-2.png"></p></li>
<li><p>填写相关的税务，银行，联系人信息。如下图所示：
<img src="/images/iap-tax-info.png"></p></li>
</ol>


<h3>开发工作(ios端)</h3>

<p>1、 在工程中引入 storekit.framework 和 #import &lt;StoreKit/StoreKit.h></p>

<p>2、 获得所有的付费Product ID列表。这个可以用常量存储在本地，也可以由自己的服务器返回。</p>

<p>3、 制作一个界面，展示所有的应用内付费项目。这些应用内付费项目的价格和介绍信息可以是自己的服务器返回。但如果是不带服务器的单机游戏应用或工具类应用，则可以通过向App Store查询获得。我在测试时发现，向App Store查询速度非常慢，通常需要2-3秒钟，所以不建议这么做，最好还是搞个自己的服务器吧。</p>

<p>4、当用户点击了一个IAP项目，我们先查询用户是否允许应用内付费，如果不允许则不用进行以下步骤了。代码如下：
``` objc</p>

<pre><code>if ([SKPaymentQueue canMakePayments]) {
    // 执行下面提到的第5步：
    [self getProductInfo];
} else {
    NSLog(@"失败，用户禁止应用内付费购买.");
}
</code></pre>

<p>```</p>

<p>5、 我们先通过该IAP的ProductID向AppStore查询，获得SKPayment实例，然后通过SKPaymentQueue的 addPayment方法发起一个购买的操作。
``` objc
// 下面的ProductId应该是事先在itunesConnect中添加好的，已存在的付费项目。否则查询会失败。
- (void)getProductInfo {</p>

<pre><code>NSSet * set = [NSSet setWithArray:@[@"ProductId"]];
SKProductsRequest * request = [[SKProductsRequest alloc] initWithProductIdentifiers:set];
request.delegate = self;
[request start];
</code></pre>

<p>}</p>

<p>// 以上查询的回调函数
- (void)productsRequest:(SKProductsRequest <em>)request didReceiveResponse:(SKProductsResponse </em>)response {</p>

<pre><code>NSArray *myProduct = response.products;
if (myProduct.count == 0) {
    NSLog(@"无法获取产品信息，购买失败。");
    return;
}
SKPayment * payment = [SKPayment paymentWithProduct:myProduct[0]];
[[SKPaymentQueue defaultQueue] addPayment:payment];
</code></pre>

<p>}
```</p>

<p>6、 在viewDidLoad方法中，将购买页面设置成购买的Observer。
``` objc
- (void)viewDidLoad {</p>

<pre><code>[super viewDidLoad];
// 监听购买结果
[[SKPaymentQueue defaultQueue] addTransactionObserver:self];
</code></pre>

<p>}</p>

<ul>
<li>(void)viewDidUnload {
  [super viewDidUnload];
  [[SKPaymentQueue defaultQueue] removeTransactionObserver:self];
}
```</li>
</ul>


<p>7、 当用户购买的操作有结果时，就会触发下面的回调函数，相应进行处理即可。
``` objc
- (void)paymentQueue:(SKPaymentQueue <em>)queue updatedTransactions:(NSArray </em>)transactions {</p>

<pre><code>for (SKPaymentTransaction *transaction in transactions)
{
    switch (transaction.transactionState)
    {
        case SKPaymentTransactionStatePurchased://交易完成
            NSLog(@"transactionIdentifier = %@", transaction.transactionIdentifier);
            [self completeTransaction:transaction];
            break;
        case SKPaymentTransactionStateFailed://交易失败
            [self failedTransaction:transaction];
            break;
        case SKPaymentTransactionStateRestored://已经购买过该商品
            [self restoreTransaction:transaction];
            break;
        case SKPaymentTransactionStatePurchasing:      //商品添加进列表
            NSLog(@"商品添加进列表");
            break;
        default:
            break;
    }
}
</code></pre>

<p>}</p>

<ul>
<li>(void)completeTransaction:(SKPaymentTransaction *)transaction {
  // Your application should implement these two methods.
  NSString * productIdentifier = transaction.payment.productIdentifier;
  NSString * receipt = [transaction.transactionReceipt base64EncodedString];
  if ([productIdentifier length] > 0) {

<pre><code>  // 向自己的服务器验证购买凭证
</code></pre>

<p>  }</p>

<p>  // Remove the transaction from the payment queue.
  [[SKPaymentQueue defaultQueue] finishTransaction: transaction];</p></li>
</ul>


<p>}</p>

<ul>
<li><p>(void)failedTransaction:(SKPaymentTransaction *)transaction {
  if(transaction.error.code != SKErrorPaymentCancelled) {</p>

<pre><code>  NSLog(@"购买失败");
</code></pre>

  } else {

<pre><code>  NSLog(@"用户取消交易");
</code></pre>

<p>  }
  [[SKPaymentQueue defaultQueue] finishTransaction: transaction];
}</p></li>
<li><p>(void)restoreTransaction:(SKPaymentTransaction *)transaction {
  // 对于已购商品，处理恢复购买的逻辑
  [[SKPaymentQueue defaultQueue] finishTransaction: transaction];
}</p></li>
</ul>


<p>```</p>

<p>8、服务器验证凭证(Optional)。如果购买成功，我们需要将凭证发送到服务器上进行验证。考虑到网络异常情况，iOS端的发送凭证操作应该进行持久化，如果程序退出，崩溃或网络异常，可以恢复重试。</p>

<h3>开发工作(服务端)</h3>

<p>服务端的工作比较简单，分4步：</p>

<ol>
<li>接收ios端发过来的购买凭证。</li>
<li>判断凭证是否已经存在或验证过，然后存储该凭证。</li>
<li>将该凭证发送到苹果的服务器验证，并将验证结果返回给客户端。</li>
<li>如果需要，修改用户相应的会员权限。</li>
</ol>


<p>考虑到网络异常情况，服务器的验证应该是一个可恢复的队列，如果网络失败了，应该进行重试。</p>

<p>与苹果的验证接口文档在<a href="https://developer.apple.com/library/ios/#documentation/NetworkingInternet/Conceptual/StoreKitGuide/VerifyingStoreReceipts/VerifyingStoreReceipts.html#//apple_ref/doc/uid/TP40008267-CH104-SW3">这里</a>。简单来说就是将该购买凭证用Base64编码，然后POST给苹果的验证服务器，苹果将验证结果以JSON形式返回。</p>

<p>苹果AppStore线上的购买凭证验证地址是<a href="https://buy.itunes.apple.com/verifyReceipt">https://buy.itunes.apple.com/verifyReceipt</a> ，测试的验证地址是：<a href="https://sandbox.itunes.apple.com/verifyReceipt">https://sandbox.itunes.apple.com/verifyReceipt</a></p>

<h2>参考链接</h2>

<p>以下参考链接详细说明了完成应用内付费开发的步骤：</p>

<ol>
<li><a href="https://developer.apple.com/appstore/in-app-purchase/index.html">https://developer.apple.com/appstore/in-app-purchase/index.html</a></li>
<li><a href="http://www.himigame.com/iphone-cocos2d/550.html">http://www.himigame.com/iphone-cocos2d/550.html</a></li>
<li><a href="http://www.cocoachina.com/iphonedev/sdk/2011/1028/3435.html">http://www.cocoachina.com/iphonedev/sdk/2011/1028/3435.html</a></li>
<li><a href="http://www.cocoachina.com/newbie/basic/2012/0214/3976.html">http://www.cocoachina.com/newbie/basic/2012/0214/3976.html</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用CocoaPods来做iOS程序的包依赖管理]]></title>
    <link href="http://blog.devtang.com/blog/2012/12/02/use-cocoapod-to-manage-ios-lib-dependency/"/>
    <updated>2012-12-02T14:09:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/12/02/use-cocoapod-to-manage-ios-lib-dependency</id>
    <content type="html"><![CDATA[<p><img src="/images/cocoapods-logo.png"></p>

<h2>前言</h2>

<p>每种语言发展到一个阶段，就会出现相应的依赖管理工具, 或者是中央代码仓库。比如</p>

<ul>
<li>Java: maven，Ivy</li>
<li>Ruby: gems</li>
<li>Python: pip, easy_install</li>
<li>Nodejs: npm</li>
</ul>


<p>随着iOS开发者的增多，业界也出现了为iOS程序提供依赖管理的工具，这个工具叫：<a href="http://cocoapods.org/">CocoaPods</a>。</p>

<!-- more -->


<h2>CocoaPods简介</h2>

<p>CocoaPods是一个负责管理iOS项目中第三方开源代码的工具。CocoaPods<a href="https://github.com/CocoaPods/CocoaPods">项目的源码</a>在Github上管理。该项目开始于2011年8月12日，经过一年多的发展，现在已经超过1000次提交，并且持续保持活跃更新。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和更新第三方开源库的时间。</p>

<p>拿我之前开发的粉笔网iPhone客户端为例，其使用了14个第三方开源库。在没有使用CocoaPods以前，我需要：</p>

<ol>
<li>把这些第三方开源库的相关文件复制到项目中，或者设置成git的submodule，然后这些开源库通常需要依赖系统的一些framework，我需要手工地将这些framework一一增加到项目依赖中，比如ASI网络库就需要增加以下framework: CFNetwork, SystemConfiguration, MobileCoreServices, CoreGraphics and zlib。</li>
<li>对于RegexKitLite这个正则表达式库，我还需要设置-licucore的编译参数</li>
<li>手工管理这些依赖包的更新。</li>
</ol>


<p>这些体力活虽然简单，但毫无技术含量并且浪费时间。在使用CocoaPods之后，我只需要将用到的第三方开源库放到一个名为Podfile的文件中，然后执行pod install。CocoaPods就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数。</p>

<h2>CocoaPods的安装和使用介绍</h2>

<h3>安装</h3>

<p>安装方式异常简单, Mac下都自带ruby，使用ruby的gem命令即可下载安装：
<code>bash
$ gem install cocoapods
$ pod setup
</code></p>

<h3>使用</h3>

<p>使用时需要新建一个名为Podfile的文件，以如下格式，将依赖的库名字依次列在文件中即可</p>

<p><code>
platform :ios
pod 'JSONKit',       '~&gt; 1.4'
pod 'Reachability',  '~&gt; 3.0.0'
pod 'ASIHTTPRequest'
pod 'RegexKitLite'
</code></p>

<p>然后你将编辑好的Podfile文件放到你的项目根目录中，执行如下命令即可：
<code>bash
cd "your project home"
pod install
</code></p>

<p>现在，你的所有第三方库都已经下载完成并且设置好了编译参数和依赖，你只需要记住如下2点即可：</p>

<ol>
<li>使用CocoaPods生成的 <em>.xcworkspace 文件来打开工程，而不是以前的 </em>.xcodeproj 文件。</li>
<li>每次更改了Podfile文件，你需要重新执行一次pod install命令。</li>
</ol>


<h3>查找第三方库</h3>

<p>你如果不知道cocoaPods管理的库中，是否有你想要的库，那么你可以通过pod search命令进行查找，以下是我用pod search json查找到的所有可用的库：</p>

<p>``` bash
$ pod search json</p>

<p>-> AnyJSON (0.0.1)
   Encode / Decode JSON by any means possible.
   - Homepage: https://github.com/mattt/AnyJSON
   - Source:   https://github.com/mattt/AnyJSON.git
   - Versions: 0.0.1 [master repo]</p>

<p>-> JSONKit (1.5pre)
   A Very High Performance Objective-C JSON Library.
   - Homepage: https://github.com/johnezang/JSONKit
   - Source:   git://github.com/johnezang/JSONKit.git
   - Versions: 1.5pre, 1.4 [master repo]</p>

<p>-> MTJSONDictionary (0.0.4)
   An NSDictionary category for when you're working with it converting to/from JSON. DEPRECATED, use MTJSONUtils
   instead.
   - Homepage: https://github.com/mysterioustrousers/MTJSONDictionary.git
   - Source:   https://github.com/mysterioustrousers/MTJSONDictionary.git
   - Versions: 0.0.4, 0.0.3, 0.0.2 [master repo]</p>

<p>-> MTJSONUtils (0.1.0)
   An NSObject category for working with JSON.
   - Homepage: https://github.com/mysterioustrousers/MTJSONUtils.git
   - Source:   https://github.com/mysterioustrousers/MTJSONUtils.git
   - Versions: 0.1.0, 0.0.1 [master repo]</p>

<p>-> SBJson (3.1.1)
   This library implements strict JSON parsing and generation in Objective-C.
   - Homepage: http://stig.github.com/json-framework/
   - Source:   https://github.com/stig/json-framework.git
   - Versions: 3.1.1, 3.1, 3.0.4, 2.2.3 [master repo]</p>

<p>-> TouchJSON (1.0)
   TouchJSON is an Objective-C based parser and generator for JSON encoded data.
   - Homepage: https://github.com/TouchCode/TouchJSON
   - Source:   https://github.com/TouchCode/TouchJSON.git
   - Versions: 1.0 [master repo]
```</p>

<h3>生成第三方库的帮助文档</h3>

<p>如果你想让CococaPods帮你生成第三方库的帮助文档，并集成到XCode中，那么用brew安装appledoc即可：</p>

<p><code>bash
brew install appledoc
</code></p>

<p>关于appledoc，我在今年初的另一篇博客<a href="http://blog.devtang.com/blog/2012/02/01/use-appledoc-to-generate-xcode-doc/">《使用Objective-C的文档生成工具:appledoc》</a>中有专门介绍。它最大的优点是可以将帮助文档集成到XCode中，这样你在敲代码的时候，按住opt键单击类名或方法名，就可以显示出相应的帮助文档。</p>

<h2>原理</h2>

<p>大概研究了一下CocoaPods的原理，它是将所有的依赖库都放到另一个名为Pods项目中，然后让主项目依赖Pods项目，这样，源码管理工作都从主项目移到了Pods项目中。发现的一些技术细节有：</p>

<ol>
<li>Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖这个.a文件即可。</li>
<li>对于资源文件，CocoaPods提供了一个名为Pods-resources.sh的bash脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。</li>
<li>CocoaPods通过一个名为Pods.xcconfig的文件来在编译时设置所有的依赖和参数。</li>
</ol>


<p>Have fun!</p>
]]></content>
  </entry>
  
</feed>
