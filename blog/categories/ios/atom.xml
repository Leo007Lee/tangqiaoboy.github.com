<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 唐巧的技术博客]]></title>
  <link href="http://blog.devtang.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.devtang.com/"/>
  <updated>2013-11-15T20:29:47+08:00</updated>
  <id>http://blog.devtang.com/</id>
  <author>
    <name><![CDATA[唐巧]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Flurry来统计和分析用户行为]]></title>
    <link href="http://blog.devtang.com/blog/2013/10/24/use-flurry-to-analyse-data/"/>
    <updated>2013-10-24T13:51:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/10/24/use-flurry-to-analyse-data</id>
    <content type="html"><![CDATA[<h2>简介</h2>

<p><img src="/images/flurry-logo.png"></p>

<p>本文为InfoQ中文站特供稿件，首发地址为：<a href="http://www.infoq.com/cn/articles/use-flurry-to-statistics-and-analysis-user-behavior">文章链接</a>。如需转载，请与InfoQ中文站联系。</p>

<p><a href="http://www.flurry.com/">Flurry</a>是一家专门为移动应用提供数据统计和分析的公司。他们的数据统计分析SDK支持的平台包括iPhone, iPad, Android, Windows Phone, Java ME和BlackBerry。使用Flurry服务的公司包括eBay、Yahoo、Hulu和Skype等超过11万家公司，涉及的应用超过36万个。</p>

<p>利用Flurry提供的分析平台，我们可以很容易地自动统计出应用的使用情况，例如：</p>

<ol>
<li>每天（每周或每月）登录用户数，应用使用次数</li>
<li>每天（每周或每月）新用户数，活跃用户数</li>
<li>用户的所在地、年龄、性别的分布情况</li>
</ol>


<p>Flurry也可以自动统计出移动设备的分类情况，例如：</p>

<ol>
<li>使用3G，Wifi的会话比例</li>
<li>使用iOS系统各版本(例如iOS6.0, iOS7.0等)的比例</li>
<li>使用iOS各种设备（例如iPhone4, iPhone5等)的比例</li>
</ol>


<p>除了上面介绍的自动统计项目，Flurry SDK也提供了统计用的相关API，便于我们针对自己产品的特点，做针对性的统计。例如统计应用中某个按钮的按下次数，或者网络请求的平均响应时间等。</p>

<!-- more -->


<h2>Flurry的基本使用</h2>

<h3>注册和下载对应SDK</h3>

<p>使用Flurry前，需要先到官方网站<a href="http://www.flurry.com/">http://www.flurry.com/</a>注册账号。然后登录到Flurry后台，依次选择 <code>"Applications" -&gt; “Add a New Application"</code> ，增加一个需要统计分析的应用。如下图所示：</p>

<p><img src="/images/flurry-create-app-1.png"></p>

<p>然后，在接下来的界面之后根据你的应用类型，选择iPhone或iPad应用。如下图所示：</p>

<p><img src="/images/flurry-create-app-2.png"></p>

<p>接着，填入应用的名字和分类（名字仅用作在Flurry后台和自己的其它应用区分，不需要和应用的真实名字相同），之后点击"Create App"，如下所示：</p>

<p><img src="/images/flurry-create-app-3.png"></p>

<p>到此，我们就成功在后台创建了一个新的应用统计和分析项目。点击下图中的"Download"，可以下载需要集成在应用中的SDK。而下图中的提示2中的Key：<code>X28BBKTNZ9H3VYTBDBG3</code>则是我们在集成时用于标识自己应用的ID。</p>

<p><img src="/images/flurry-create-app-4.png"></p>

<h3>集成SDK</h3>

<p>我们将下载后的SDK解压，可以看到文件列表如下。列表中对我们最重要的文件是Flurry目录下的<code>flurry.h</code>文件和<code>libFlurry_4.3.0.a</code>文件。这2个文件需要复制到Xcode的工程中去。</p>

<p>而<code>ProjectApiKey.txt</code>文件中记录了我们之前创建的应用ID，在在代码中调用SDK初使化时需要使用。</p>

<p><img src="/images/flurry-sdk-files.png"></p>

<p>接着我们打开Xcode工程，将之前下载解压的Flurry目录拖动添加到工程中，同时在工程的.pch文件中加上 <code>#import "Flurry.h"</code>，如下图所示：</p>

<p><img src="/images/flurry-setup-in-xcode.png"></p>

<p>接着我们在<code>Link Binary With Libraries</code>中加入如下2个依赖的framework:</p>

<ul>
<li>Security.framework</li>
<li>SystemConfiguration.framework。</li>
</ul>


<p><img src="/images/flurry-link-library.png"></p>

<p>接着我们打开 <code>AppDelegate.m</code>，在<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>方法中，加入代码<code>[Flurry startSession:@"X28BBKTNZ9H3VYTBDBG3"];</code>，如下图所示：</p>

<p><img src="/images/flurry-set-api-key.png"></p>

<p>这样，就完成了Flurry最简单的集成。通过以上短短几步，Flurry就可以帮我们完成应用的基本使用数据的统计和分析。</p>

<h3>自定义统计项</h3>

<p>Flurry提供了<code>logEvent</code>函数，用于实现自定义的统计项。默认情况下，该函数接受一个参数，用于表示当前统计项的名字。</p>

<p>例如我们的界面中有2个按钮，我们想统计它们各自被用户的点击次数，则可以如下代码实现。在该代码中，我们定义了2个自定义的统计项，名字分别为<code>First Button Pressed</code>和<code>Second Button Pressed</code>。</p>

<p><img src="/images/flurry-logevent.png"></p>

<p><code>logEvent</code>函数也支持添加各种参数，用于做更加精细的统计，例如，我们想在统计用户在同一个页面，点击时不同按钮的次数分布，看哪些按钮更加常用，则统计代码可以如下实现：</p>

<p><img src="/images/flurry-logevent-with-parameters.png"></p>

<p><code>logEvent</code>函数也支持统计时间，常常用来统计某个复杂的网络操作的耗时或者用户对于某些界面的响应时间。例如，我们想统计用户停留在某个提示界面的时间，则可以用如下代码完成：</p>

<p><img src="/images/flurry-log-event-time.png"></p>

<h3>查看统计结果</h3>

<p>完成上面的自定义统计的代码后，待应用发布后，我们就可以从后台的<code>Events</code>栏中看到相应的统计结果了。如下图所示：</p>

<p><img src="/images/flurry-view-events.png"></p>

<h3>统计Crashlog</h3>

<p>Flurry从4.2.3开始，支持应用的Crashlog统计。只需要在<code>AppDelegate.m</code>文件中，在调用<code>startSession</code>方法之前，调用<code>setCrashReportingEnabled:YES</code>即可：</p>

<p><code>
[Flurry setCrashReportingEnabled:YES];
[Flurry startSession:@"YOUR_API_KEY"];
</code></p>

<p>这里注意，<font color='red'>一定要在startSession之前调用setCrashReportingEnabled，否则将无法记录Crashlog信息！切记！！</font></p>

<p>之后你就可以从后台管理界面的<code>Errors</code>项中，获得应用的Crashlog信息。</p>

<h2>和其它统计分析平台的对比</h2>

<p>和著名的统计工具<a href="http://www.google.com/analytics/">Google Analytics</a>相比，Flurry的优点是：</p>

<ol>
<li>Flurry专门针对移动端做了许多优化，例如统计流量就小很多。</li>
<li>Flurry没有被墙的问题。</li>
</ol>


<p>Flurry缺点是:</p>

<ol>
<li>Google Analytics的统计功能相对更强大一些。</li>
<li>Google Analytics可以和网页版的统计数据做整合。</li>
</ol>


<p>和国内的分析平台<a href="http://www.umeng.com/">友盟</a>相比，Flurry的优点是：</p>

<ol>
<li>使用Flurry的应用相对更多。根据Flurry和友盟的官方数据，有超过36万应用使用Flurry<sup><a href="http://www.flurry.com/big-data.html">1</a> </sup>，有超过18万应用使用友盟<sup><a href="http://www.umeng.com/analytics">2</a></sup>。</li>
<li>Flurry是国外的公司，保持独立和专注，数据安全性更高；友盟现在已经<a href="http://tech.163.com/13/0426/16/8TDB6H1N00094MOK.html">被阿里收购</a>，当用户的应用涉及领域和阿里有类似或重合的时候，那么该统计数据有潜在的安全性问题。</li>
</ol>


<p>Flurry的缺点是：</p>

<ol>
<li>友盟因为是中国公司，所以对国内开发者非常友善，相关的文档或界面都是中文的。而Flurry并不提供中文的后台管理界面或相关文档。</li>
<li>Flurry的服务器在国外，在响应速度上应该相对比友盟慢一些。但在测试中，Flurry服务器都保证了500ms左右的响应时间，还是比较好的。</li>
</ol>


<h2>总结</h2>

<p>本文介绍了Flurry的基本功能以及如何做自定义的统计，最后与业界其它同类工具做了对比。我也将相关示例代码整理到github上，地址是：<a href="https://github.com/tangqiaoboy/FlurryUsageSample">https://github.com/tangqiaoboy/FlurryUsageSample</a>，愿本文能帮助你更加方便地做应用的统计和分析工作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[猿题库iOS客户端的技术细节（三）：基于CoreText的排版引擎]]></title>
    <link href="http://blog.devtang.com/blog/2013/10/21/the-tech-detail-of-ape-client-3/"/>
    <updated>2013-10-21T16:15:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/10/21/the-tech-detail-of-ape-client-3</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>本人今年主要在负责猿题库iOS客户端的开发，本文旨在通过分享猿题库iOS客户端开发过程中的技术细节，达到总结和交流的目的。</p>

<p>这是本技术分享系列文章的第三篇。本文涉及的技术细节是：基于CoreText的排版引擎。</p>

<!-- more -->


<h2>CoreText概述</h2>

<p>因为猿题库的做题和解析界面需要复杂的排版，所以我们基于CoreText实现了自己的富文本排版引擎。我们的排版引擎对公式、图片和链接有着良好支持，并且支持各种字体效果混排。对于内容中的图片，支持点击查看大图功能，对于内容中的链接，支持点击操作。</p>

<p>下图是我们应用的一个截图，可以看到公式，图片与文字混排良好。</p>

<p><img src="/images/ape-coretext-1.png"></p>

<p>对于富文本排版，除了可以用CoreText实现外，还可以用UIWebView实现。我以前写过一篇介绍如何用UIWebView进行复杂内容显示和交互的文章<a href="http://blog.devtang.com/blog/2012/03/24/talk-about-uiwebview-and-phonegap/">《关于UIWebView和PhoneGap的总结》</a>，里面介绍了使用UIWebView如何处理参数传递，同步与异步等问题，感兴趣的同学也可以翻看。</p>

<p>基于CoreText来实现和基于UIWebView来实现相比，前者有以下好处：</p>

<ol>
<li>CoreText占用的内存更少，UIWebView占用的内存更多。</li>
<li>CoreText在渲染界面前就可以精确地获得显示内容的高度（只要有了CTFrame即可），而UIWebView只有渲染出内容后，才能获得内容的高度（而且还需要用javascript代码来获取）</li>
<li>CoreText的CTFrame可以在后台线程渲染，UIWebView的内容只能在主线程（UI线程）渲染。</li>
<li>基于CoreText可以做更好的原生交互效果，交互效果可以更细腻。而UIWebView的交互效果都是用javascript来实现的，在交互效果上会有一些卡顿存在。例如，在UIWebView下，一个简单的按钮按下效果，都无法做到原生按钮的即时和细腻的按下效果。</li>
</ol>


<p>当然基于CoreText的方案也有一些劣势：</p>

<ol>
<li>CoreText渲染出来的内容不能像UIWebView那样方便地支持内容的复制。</li>
<li>基于CoreText来排版，需要自己处理图片排版相关的逻辑，也需要自己处理链接点击操作的支持。</li>
</ol>


<p>我们最初的猿题库行测第一版采用了基于UIWebView来实现，但是做出来发现一些小的交互细节无法做到精致。所以后来的第二版我们就全部转成用CoreText实现，虽然实现成本上增加了不少，但是应用的交互效果好多了。</p>

<p>使用CoreText也为我们后来的iPad版提供了技术积累，因为iPad版的页面排版更加复杂，用UIWebView是完全无法完成相应的交互和排版需求的。</p>

<p>关于如何基于CoreText来做一个排版引擎，我主要参考的是这篇教程：<a href="http://www.raywenderlich.com/4147/core-text-tutorial-for-ios-making-a-magazine-app">《Core Text Tutorial for iOS: Making a Magazine App》</a> 以及<a href="https://github.com/jverkoey/nimbus">Nimbus</a> 中的<a href="https://github.com/jverkoey/nimbus/blob/master/src/attributedlabel/src/NIAttributedLabel.m">NIAttributeLabel.m</a> 的实现，在这里我就不重复教程中的内容了，我主要讲一些实现细节。</p>

<h2>实现细节</h2>

<h3>服务端接口</h3>

<p>我们在后台实现了一个基于<a href="http://baike.baidu.com/view/168792.htm">UBB</a> 的富文本编译器。使用UBB的原因是：</p>

<ol>
<li>UBB相对于HTML来说，虽然功能较简单，但是能完全满足我们对于富文本排版的需求。</li>
<li>做一个UBB的语法解析器比较简单，便于我们将UBB渲染到各个平台上。</li>
</ol>


<p>为了简化iOS端的实现，我们将UBB的语法解析在服务器端完成。服务器端提供了接口，可以直接获得将UBB解析成类似HTML的<a href="http://baike.baidu.com/subview/14806/8904138.htm?fromId=14806&amp;from=rdtself">文件对象模型(DOM)</a> 的树型数据结构。有了这个树型数据结构，iOS端渲染就简单多了，无非就是递归遍历树型节点，将相关的内容转换成 NSAttributeString即可，之后将NSAttrubiteString转成CoreText的CTFrame即可用于界面的绘制。</p>

<h3>支持图文混排</h3>

<p>支持图文混排在教程：<a href="http://www.raywenderlich.com/4147/core-text-tutorial-for-ios-making-a-magazine-app">《Core Text Tutorial for iOS: Making a Magazine App》</a> 中有介绍，我们在解析DOM树遇到图片节点时，则将该内容转成一个空格，随后设置该空格在绘制时，需要我们自己指定宽高相关信息，而宽高信息在图片节点中都有提供。这样，CoreText引擎在绘制时，就会把相关的图片位置留空，之后我们将图片异步下来下来后，使用CoreGraph相关的API将图片再画在界面上，就实现了图文混排功能。</p>

<p>下面的相关的示例代码：</p>

<p>``` objc
/<em> Callbacks </em>/
static void deallocCallback( void* ref ){</p>

<pre><code>[(id)ref release];
</code></pre>

<p>}
static CGFloat ascentCallback( void *ref ){</p>

<pre><code>CGFloat height = [(NSString*)[(NSDictionary*)ref objectForKey:@"height"] floatValue];
return height/2 + [FrameParserConfig sharedInstance].baselineFromMid;
</code></pre>

<p>}
static CGFloat descentCallback( void *ref ){</p>

<pre><code>CGFloat height = [(NSString*)[(NSDictionary*)ref objectForKey:@"height"] floatValue];
return height/2 - [FrameParserConfig sharedInstance].baselineFromMid;
</code></pre>

<p>}
static CGFloat widthCallback( void* ref ){</p>

<pre><code>return [(NSString*)[(NSDictionary*)ref objectForKey:@"width"] floatValue];
</code></pre>

<p>}</p>

<ul>
<li>(void)appendDelegateData:(NSDictionary <em>)delegateData ToString:(NSMutableAttributedString</em>)contentString {
  //render empty space for drawing the image in the text //1
  CTRunDelegateCallbacks callbacks;
  callbacks.version = kCTRunDelegateCurrentVersion;
  callbacks.getAscent = ascentCallback;
  callbacks.getDescent = descentCallback;
  callbacks.getWidth = widthCallback;
  callbacks.dealloc = deallocCallback;
  CTRunDelegateRef delegate = CTRunDelegateCreate(&amp;callbacks, delegateData);
  [delegateData retain];
  // Character to use as recommended by kCTRunDelegateAttributeName documentation.
  // use " " will lead to wrong width in CTFramesetterSuggestFrameSizeWithConstraints
  unichar objectReplacementChar = 0xFFFC;
  NSString * objectReplacementString = [NSString stringWithCharacters:&amp;objectReplacementChar length:1];
  NSDictionary * attributes = [self getAttributesWithStyleArray:nil];
  //try to apply linespacing attributes to this placeholder
  NSMutableAttributedString * space = [[NSMutableAttributedString alloc] initWithString:objectReplacementString attributes:attributes];
  CFAttributedStringSetAttribute((CFMutableAttributedStringRef)space, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);
  CFRelease(delegate);
  [contentString appendAttributedString:space];
  [space release];</li>
</ul>


<p>}</p>

<p>```</p>

<p>这里需要注意的是，用来代替图片的占位符使用空格会带来排版上的异常，具体原因未知，我们猜测是CoreText的bug，参考<a href="https://github.com/jverkoey/nimbus">Nimbus</a> 的实现后，我们使用 <code>0xFFFC</code>作为占位符，就没有遇到问题了。</p>

<h3>支持链接</h3>

<p>支持链接点击的主要实现的方式是：</p>

<ol>
<li>在解析DOM树的时候，记录下链接串在整个富文本中的位置信息（包括offset和length)。</li>
<li>在CoreText渲染到的view上，监听用户操作事件，使用 <code>CTLineGetStringIndexForPosition</code>函数来获得用户点击的位置对应 <code>NSAttributedString</code> 字符串上的位置信息（index)
3.判断第2步得到的index是否在第一步记录的各个链接的区间范围内，如果在范围内，则表示用户点击了某一个链接。</li>
</ol>


<p>这段逻辑的关键代码如下：</p>

<p>``` objc
// test touch point is on link or not
+ (LinkData <em>)touchLinkInView:(UIView </em>)view atPoint:(CGPoint)point data:(CTTableViewCellData *)data {</p>

<pre><code>CTFrameRef textFrame = data.ctFrame;
CFArrayRef lines = CTFrameGetLines(textFrame);
if (!lines) return nil;
CFIndex count = CFArrayGetCount(lines);
LinkData *foundLink = nil;

CGPoint origins[count];
CTFrameGetLineOrigins(textFrame, CFRangeMake(0,0), origins);

// CoreText context coordinates are the opposite to UIKit so we flip the bounds
CGAffineTransform transform =  CGAffineTransformScale(CGAffineTransformMakeTranslation(0, view.bounds.size.height), 1.f, -1.f);

for (int i = 0; i &lt; count; i++) {
    CGPoint linePoint = origins[i];
    CTLineRef line = CFArrayGetValueAtIndex(lines, i);
    CGRect flippedRect = [self getLineBounds:line point:linePoint];
    CGRect rect = CGRectApplyAffineTransform(flippedRect, transform);

    if (CGRectContainsPoint(rect, point)) {
        CGPoint relativePoint = CGPointMake(point.x-CGRectGetMinX(rect),
                                            point.y-CGRectGetMinY(rect));
        CFIndex idx = CTLineGetStringIndexForPosition(line, relativePoint);
        foundLink = [self linkAtIndex:idx linkArray:data.linkArray];
        return foundLink;
    }
}
return nil;
</code></pre>

<p>}</p>

<p>```</p>

<h3>基于CoreText的内容省略</h3>

<p>我们在使用CoreText时，还遇到一个具体排版上的问题。正常情况下，在生成CTFrame之后，只需要调用：<code>CTFrameDraw(self.data.ctFrame, context);</code>即可完成界面的绘制。但是产品提出了一个需求，对于某些界面，当显示不下的时候，需要将多余内容用<code>...</code>来表示。这让我们的绘制逻辑需要特别处理，以下是具体的实现：</p>

<p>``` objc</p>

<p>static NSString* const kEllipsesCharacter = @"\u2026";
CGPathRef path = CTFrameGetPath(<em>data.ctFrame);
CGRect rect = CGPathGetBoundingBox(path);
CFArrayRef lines = CTFrameGetLines(</em>data.ctFrame);
CFIndex lineCount = CFArrayGetCount(lines);
NSInteger numberOfLines = MIN(_numberOfLines, lineCount);</p>

<p>CGPoint lineOrigins[numberOfLines];
CTFrameGetLineOrigins(<em>data.ctFrame, CFRangeMake(0, numberOfLines), lineOrigins);
NSAttributedString *attributedString = </em>data.attributedString;</p>

<p>for (CFIndex lineIndex = 0; lineIndex &lt; numberOfLines; lineIndex++) {</p>

<pre><code>CGPoint lineOrigin = lineOrigins[lineIndex];
lineOrigin.y =  self.frame.size.height + (lineOrigin.y - rect.size.height);
CGContextSetTextPosition(context, lineOrigin.x, lineOrigin.y);
CTLineRef line = CFArrayGetValueAtIndex(lines, lineIndex);

BOOL shouldDrawLine = YES;

if (lineIndex == numberOfLines - 1) {
    CFRange lastLineRange = CTLineGetStringRange(line);
    if (lastLineRange.location + lastLineRange.length &lt; (CFIndex)attributedString.length) {
        CTLineTruncationType truncationType = kCTLineTruncationEnd;
        NSUInteger truncationAttributePosition = lastLineRange.location + lastLineRange.length - 1;

        NSDictionary *tokenAttributes = [attributedString attributesAtIndex:truncationAttributePosition
                                                             effectiveRange:NULL];
        NSAttributedString *tokenString = [[NSAttributedString alloc] initWithString:kEllipsesCharacter
                                                                          attributes:tokenAttributes];
        CTLineRef truncationToken = CTLineCreateWithAttributedString((__bridge CFAttributedStringRef)tokenString);

        NSMutableAttributedString *truncationString = [[attributedString attributedSubstringFromRange:NSMakeRange(lastLineRange.location, lastLineRange.length)] mutableCopy];
        if (lastLineRange.length &gt; 0) {
            // Remove any whitespace at the end of the line.
            unichar lastCharacter = [[truncationString string] characterAtIndex:lastLineRange.length - 1];
            if ([[NSCharacterSet whitespaceAndNewlineCharacterSet] characterIsMember:lastCharacter]) {
                [truncationString deleteCharactersInRange:NSMakeRange(lastLineRange.length - 1, 1)];
            }
        }
        [truncationString appendAttributedString:tokenString];

        CTLineRef truncationLine = CTLineCreateWithAttributedString((__bridge CFAttributedStringRef)truncationString);
        CTLineRef truncatedLine = CTLineCreateTruncatedLine(truncationLine, self.size.width, truncationType, truncationToken);
        if (!truncatedLine) {
            // If the line is not as wide as the truncationToken, truncatedLine is NULL
            truncatedLine = CFRetain(truncationToken);
        }
        CFRelease(truncationLine);
        CFRelease(truncationToken);

        CTLineDraw(truncatedLine, context);
        CFRelease(truncatedLine);

        shouldDrawLine = NO;
    }
}

if (shouldDrawLine) {
    CTLineDraw(line, context);
}
</code></pre>

<p>}</p>

<p>```</p>

<h2>后记</h2>

<p>以上源码很多都参考了<a href="https://github.com/jverkoey/nimbus">Nimbus</a>的实现，在此再一次表达一下对开源社区的感谢。</p>

<p>在大约2年前，CoreText还是一个新玩意。那时候微博的界面都还是用控件组合得到的。慢慢的，大家都开始接受CoreText，很多应用都广泛地将CoreText应用于自己的界面中，做出来了更加复杂的排版、交互效果。在iOS7之后，苹果推出了更加易于使用的TextKit，使得富文本排版更加容易，相信以后的iOS应用界面会更加美观，交互更加绚丽。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[猿题库iOS客户端的技术细节（二）：答题卡扫描算法]]></title>
    <link href="http://blog.devtang.com/blog/2013/10/19/the-tech-detail-of-ape-client-2/"/>
    <updated>2013-10-19T11:10:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/10/19/the-tech-detail-of-ape-client-2</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>本人今年主要在负责猿题库iOS客户端的开发，本文旨在通过分享猿题库iOS客户端开发过程中的技术细节，达到总结和交流的目的。</p>

<p>这是本技术分享系列文章的第二篇。本文涉及的技术细节是：答题卡扫描算法。</p>

<!-- more -->


<h3>问题描述</h3>

<p>我们在调研用户需求的时候，发现有些用户很喜欢我们的猿题库产品，因为我们会根据用户对当前课程的知识点掌握情况，智能地给他出题。但是部分用户还是习惯在纸上做题，所以我们提供了试卷打印功能。</p>

<p>但是，用户如果在纸上答题，无法方便地将答案上传到我们的服务器上。如果我们没有了用户做题数据，就无法根据他的成绩，做针对性的推荐和分析。所以，我们想到一种办法：<strong>用户像传统考试那样，将答题结果填涂在答题卡上，然后我们提供一种用手机摄像头采集填涂结果的答题卡扫描算法，方便用户上传答题数据。</strong></p>

<p><img src="/images/ape-card-1.jpg"></p>

<p>上图是一个我们试验用的答题卡，通过手机摄像头获取，从中可以看到，该答题卡有以下问题：</p>

<ol>
<li>由于手机摄像头无法完全正对答题卡，拍照角度有偏曲，答题卡在拍照后并不是完全的矩形。</li>
<li>用户填涂区域可能并不饱满和完整。</li>
<li>答题纸边缘可能有用户的草稿或其它干扰识别的信息。</li>
</ol>


<h3>技术解决方案</h3>

<p>我们尝试了多种识别方案，最终采用的方案如下：</p>

<ol>
<li>图象预处理，压缩图像大小，转彩色图像为灰度图像</li>
<li>识别答题卡区域</li>
<li>图象纠偏</li>
<li>答案区域识别</li>
</ol>


<p>该方案及相关算法细节我们还在申请专利，由于专利还在申请过程中，所以我们这次仅展示上述主要步骤的示例图片。等专利完全申请结束后，我会在此将算法细节公开。</p>

<p>上述主要步骤的示例图如下：</p>

<h4>原始图</h4>

<p><img src="/images/ape-card-1.jpg"></p>

<h4>识别答题卡区域</h4>

<p><img src="/images/ape-card-2.jpg"></p>

<h4>图象纠偏</h4>

<p><img src="/images/ape-card-3.jpg"></p>

<h4>答案区域识别</h4>

<p>答案已标注在图片每个题号的右边位置：</p>

<p><img src="/images/ape-card-4.jpg"></p>

<h3>算法质量</h3>

<h4>算法正确率和召回率</h4>

<p>我们用收集来的1000套样本数据对算法进行评测，最终结果是：扫描题目准确率达到99.67%，召回率达到99.14%。主要识别失败的样本是：页面严重扭曲弯折的答题卡。我们也在一直改进算法，希望能够给用户提供更加精准的扫描结果。</p>

<h4>算法执行时间</h4>

<p>我们觉得让用户直接对着答题卡用拍摄的方式动态识别，比先拍一张照片再识别的方式更加方便。所以我们对答题卡识别算法的执行时间进行了一系列优化，最终保证每次识别时间小于0.1秒，这样的识别时间非常快，基本上用户把手机摄像头对准答题卡，扫描结果就出来了。</p>

<h2>算法的调试和移植</h2>

<p>由于我们整个技术团队都使用Mac电脑进行开发，所以我们对于算法的调试都是在Mac平台上完成的，我使用了开源的图象处理库OpenCV，在搭建OpenCV环境时遇到一些问题，最终完成环境搭建后，我将相关的经验总结在博文<a href="http://blog.devtang.com/blog/2012/10/27/use-opencv-in-ios/">《在MacOS和iOS系统中使用OpenCV》</a>中。</p>

<p>由于算法需要同时应用在iOS和Android平台，所以我主要用C++语言实现算法。Xcode可以很好地支持Objective-C语言和C++语言混编，只需要将相关的源文件扩展名从.m改为.mm即可。而Android平台所采用的Java语言，也支持通过<a href="http://en.wikipedia.org/wiki/Java_Native_Interface">JNI</a>的方式来调用C++的代码。这样就可以方便地将识别算法移植到手机中了。</p>

<h2>总结</h2>

<p>本文介绍了猿题库iOS客户端采用的答题卡扫描算法的大致步骤，以及算法的质量和移植方案。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[猿题库iOS客户端的技术细节（一）：使用多target来构建大量相似App]]></title>
    <link href="http://blog.devtang.com/blog/2013/10/17/the-tech-detail-of-ape-client-1/"/>
    <updated>2013-10-17T00:43:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/10/17/the-tech-detail-of-ape-client-1</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>本人今年主要在负责猿题库iOS客户端的开发，本文旨在通过分享猿题库iOS客户端开发过程中的技术细节，达到总结和交流的目的。</p>

<p>这是本技术分享系列文章的第一篇。本文涉及的技术细节是：采用多Target编译方案来实现多个相似App的开发，以保证我们能够快速地推出多个相似课程的客户端。</p>

<!-- more -->


<h3>问题描述</h3>

<p>今年春节后，我们对外发布了应用<a href="http://yuantiku.com/m?courseSet=xingce">“猿题库-公务员考试行测”</a>，接着我们就开始一个个发布猿题库系列课程应用。到现在半年多过去了，我们一共对外发布了8款应用（如下图所示）。</p>

<p><img src="/images/ape-arch-1.jpg"></p>

<p>这些课程，随了<a href="http://yuantiku.com/m?courseSet=shenlun">"猿题库-公务员考试申论"</a>和其它课程不一样之外，另外7个课程都有着相似，但是又不完全相同的功能和界面。</p>

<p>这些应用的相同点包括：</p>

<ol>
<li>基本相同的注册和登录以及首页逻辑和界面（只是背景图片不一样而已）。</li>
<li>相同的做题逻辑和界面。</li>
<li>基本相同的答题报告显示界面。</li>
<li>基本相同的能力评估报告界面。</li>
</ol>


<p>不同点主要包括：</p>

<ol>
<li>应用图标，启动画面，应用启动后的首页都不一样。</li>
<li>有些课程（例如公务员考试和高考）是有目标考试的概念，不同的目标考试大纲是不一样的。拿高考来举例，北京的高考和上海的高考，就有着完全不一样的考试大纲。高考的文科和理科，又有着完全不同的考试科目。</li>
<li>有些课程会有一些自定义的界面，例如高考的应用可以设置昵称，有些课程的真题练习中是有推荐真题模块的，而有些课程又没有。</li>
<li>有些课程有扫描答题卡功能，有些课程有考前冲刺功能，有些课程有大题专项查看功能，而有些课程又没有上述功能。另外还有一些微小细节，但是解决方法和类似，所以就不一一展开说明。</li>
</ol>


<h3>技术解决方案</h3>

<p>我们的技术解决方案主要说来分4步：</p>

<ol>
<li>通过抽取子项目，构建可复用的大模块。</li>
<li>通过多Target编译的方式，不同课程的在编译时，采用不同的资源文件和源文件。</li>
<li>在第2步的基础上，在项目中创建配置用的Config类，然后在不同Target各自的配置文件中设置不同的Config值。实现课程的差异化界面。</li>
<li>从不同的xib中加载界面。</li>
</ol>


<h4>抽取子项目</h4>

<p>我们首先做的是抽取子项目，从<a href="http://yuantiku.com/m?courseSet=sikao">“猿题库司法考试客户端"</a>开始，我们将可以重用的模块一一抽取出来，以git submodule的形式组织到项目中。这个抽取过程在开发完猿题库司法考试客户端之后，基本成型了。我们抽取的submodule主要分为4部分：</p>

<ol>
<li>UI Common，涉及可复用的登录界面，注册界面，付费界面，NPS界面，意见反馈界面，关于界面，扫描答题卡界面。另外，我们将一些可复用的UI风格控件也抽取成了相应的静态工厂方法，用于生成统一风格的按钮、背景以及状态栏等。</li>
<li>Core Common，涉及可复用的底层模块。包括网络请求模块，自己封装的Core Text渲染引擎，缓存模块，一些静态util方法等。</li>
<li>Lib Common，所有第三方的开源库依赖，有部分代码根据我们的需求做了修改和定制。</li>
<li>Scan Common, 答题卡扫描识别算法模块，实现核心的扫描算法。</li>
</ol>


<p>以上只是粗粒度划分，这些模块化的子项目可能在以后被重用，例如Core Common完全就可以复用在任何其它项目中。</p>

<h4>构造多个编译Target</h4>

<p>抽取完子项目以后，我们采用多target的方式，将不同课程中的同名资源文件打包进各自的Target中，最后所有课程在一个工程项目中，如下图所示：</p>

<p><img src="/images/ape-targets.jpg"></p>

<p>先简单介绍一下Xcode中target的概念，苹果在文档中写道：</p>

<p><blockquote><p></p></p><p><p>Targets that define the products to build. A target organizes the files and instructions needed to build a product into a sequence of build actions that can be taken.”</p></p><p><p></p></blockquote></p>

<p>在Xcode的一个项目中，可以允许建立多个编译的target，每个target代表着最终编译出来的一个App文件，在每个target中，可以添加不同的编译源文件和资源文件。最终，通过我们在不同target之间，修改其 <code>Copy Bundle Resources</code> 和 <code>Compile Sources</code> 配置，使课程之间的差异性得到实现。我们具体的配置方案如下：</p>

<ol>
<li><p>我们的每个课程的资源文件都具有相同的文件名，例如首页背景都叫 HomeBackgroundBg.png ，由于每个课程背景不一样，所以我们在工程中，每一个课程target下，通过修改<code>Copy Bundle Resources</code>，使其都配置有不同的（但是同名） HomeBackgroundBg.png 。这样的好处是，在代码逻辑层面，我们可以完全不用处理课程间资源文件的差异性问题。资源文件的差异性都是通过配置文件来保证的。</p></li>
<li><p>对于文案一类的差别，我们通过修改<code>Compile Sources</code>，使不同的课程有着不同的文案定义文件。通过这样，我们使不同课程有了不同的文案。另外包括后台网络接口的差异性问题，统计项的差异性问题，也都是这样处理的。</p></li>
</ol>


<h4>Config类</h4>

<p>最后，我们使用Config类来完成交互和页面UI组件差异性问题。拿能力评估报告页面来说，不同的课程的页面都有一些差异。我们在公共层的代码中将这些逻辑全部实现，具体的UI在呈现时，通过读取相关的Config类来决定具体如何展示。这样，我们只需要在第2步提供的各个课程的差异性源文件中，完成Config类的配置即可。</p>

<h4>从不同的xib中加载界面</h4>

<p>有些时候，我们仅仅需要的是UI界面排列方式不一样，其它交互逻辑完全一样。对于这种需求，我们尝试同一个view对应有多个xib，然后通过上一步的Config类的信息，来加载不同的xib界面。这样所有的差异性都在不同的xib中解决了，对controller层可以完全透明。</p>

<p>下图是我们报告页面的xib界面，分为：高考课程、有目标考试的课程、没有目标考试的课程三种。由于这3个界面的后台逻辑和交互逻辑都一样，我们通过3个xib来实现它们之间差异性的部分。</p>

<p><img src="/images/ape-xibs.jpg"></p>

<p>以下是view加载对应的xib的代码逻辑：</p>

<p>``` objc</p>

<ul>
<li>(IPadAbilityReportHeaderView <em>)loadFromNib:(IPadAbilityReportHeaderViewType)type {
  NSString </em>nibFileName;
  switch (type) {

<pre><code>  case IPadAbilityReportHeaderViewTypeWithQuiz:
      nibFileName = @"IPadAbilityReportHeaderViewWithQuiz";
      break;
  case IPadAbilityReportHeaderViewTypeWithoutQuiz:
      nibFileName = @"IPadAbilityReportHeaderViewWithoutQuiz";
      break;
  case IPadAbilityReportHeaderViewTypeGaokao:
      nibFileName = @"IPadAbilityReportHeaderViewInGaokao";
      break;
  default:
      break;
</code></pre>

  }
  NSArray *nibArray = [[NSBundle mainBundle] loadNibNamed:nibFileName owner:nil options:nil];
  if (nibArray.count > 0) {

<pre><code>  return [nibArray lastObject];
</code></pre>

  } else {

<pre><code>  return nil;
</code></pre>

<p>  }
}</p></li>
</ul>


<p>```</p>

<h2>总结</h2>

<p>通过多target编译方案，我们可以很方便的实现多个相似App的开发，以保证我们能够快速地推出多个相似课程的客户端。同时，由于在一个工程中，我们也可以方便地测试新的代码逻辑在各个课程下是否正常。</p>

<p>该方案可以用来解决“维护大量逻辑相似但是又有细微不同的应用”的需求，希望本文能给业界同行一些帮助。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C对象模型及应用]]></title>
    <link href="http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/"/>
    <updated>2013-10-15T20:31:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/10/15/objective-c-object-model</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>原创文章，转载请注明出自<a href="http://blog.devtang.com">唐巧的技术博客</a>。</p>

<p>本文主要介绍Objective-C对象模型的实现细节，以及Objective-C语言对象模型中对<code>isa swizzling</code>和<code>method swizzling</code>的支持。希望本文能加深你对Objective-C对象的理解。</p>

<h2>ISA指针</h2>

<p>Objective-C是一门面向对象的编程语言。每一个对象都是一个类的实例。在Objective-C语言的内部，每一个对象都有一个名为isa的指针，指向该对象的类。每一个类描述了一系列它的实例的特点，包括成员变量的列表，成员函数的列表等。每一个对象都可以接受消息，而对象能够接收的消息列表是保存在它所对应的类中。</p>

<p>在XCode中按<code>Shift + Command + O</code>, 然后输入NSObject.h和objc.h，可以打开NSObject的定义头文件，通过头文件我们可以看到，NSObject就是一个包含isa指针的结构体，如下图所示：</p>

<!-- more -->


<p><img src="/images/class-nsobject-isa.jpg">
<img src="/images/class-objc-object-isa.jpg"></p>

<p>按照面向对象语言的设计原则，所有事物都应该是对象（严格来说Objective-C并没有完全做到这一点，因为它有象int, double这样的简单变量类型）。在Objective-C语言中，每一个类实际上也是一个对象。每一个类也有一个名为isa的指针。每一个类也可以接受消息，例如<code>[NSObject alloc]</code>，就是向NSObject这个类发送名为<code>alloc</code>消息。</p>

<p>在XCode中按<code>Shift + Command + O</code>, 然后输入runtime.h，可以打开Class的定义头文件，通过头文件我们可以看到，Class也是一个包含isa指针的结构体，如下图所示。（图中除了isa外还有其它成员变量，但那是为了兼容非2.0版的Objective-C的遗留逻辑，大家可以忽略它。）</p>

<p><img src="/images/class-objc-class-isa.jpg"></p>

<p>因为类也是一个对象，那它也必须是另一个类的实列，这个类就是元类(<code>metaclass</code>)。元类保存了类方法的列表。当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现，如果没有，则该元类会向它的父类查找该方法，直到一直找到继承链的头。</p>

<p>元类(<code>metaclass</code>)也是一个对象，那么元类的isa指针又指向哪里呢？为了设计上的完整，所有的元类的isa指针都会指向一个根元类(root <code>metaclass</code>)。根元类(root metaclass)本身的isa指针指向自己，这样就行成了一个闭环。上面提到，一个对象能够接收的消息列表是保存在它所对应的类中的。在实际编程中，我们几乎不会遇到向元类发消息的情况，那它的isa指针在实际上很少用到。不过这么设计保证了面向对象的干净，即所有事物都是对象，都有isa指针。</p>

<p>我们再来看看继承关系，由于类方法的定义是保存在元类(<code>metaclass</code>)中，而方法调用的规则是，如果该类没有一个方法的实现，则向它的父类继续查找。所以，为了保证父类的类方法可以在子类中可以被调用，所以子类的元类会继承父类的元类，换而言之，类对象和元类对象有着同样的继承关系。</p>

<p>我很想把关系说清楚一些，但是这块儿确实有点绕，下面这张图或许能够让大家对isa和继承的关系清楚一些（该图片来自<a href="http://www.sealiesoftware.com/blog/class%20diagram.pdf">这里</a>）</p>

<p><img src="/images/class-diagram.jpg"></p>

<p>该图中，最让人困惑的莫过于Root Class了。在实现中，Root Class是指NSObject，我们可以从图中看出：</p>

<ol>
<li>NSObject类包括它的对象实例方法。</li>
<li>NSObject的元类包括它的类方法，例如alloc方法。</li>
<li>NSObject的元类继承自NSObject类。</li>
<li>一个NSObject的类中的方法同时也会被NSObject的子类在查找方法时找到。</li>
</ol>


<h2>类的成员变量</h2>

<p>如果把类的实例看成一个C语言的结构体（struct），上面说的isa指针就是这个结构体的第一个成员变量，而类的其它成员变量依次排列在结构体中。排列顺序如下图所示（图片来自《iOS 6 Programming Pushing the Limits》）：</p>

<p><img src="/images/class-member.jpg"></p>

<p>为了验证该说法，我们在XCode中新建一个工程，在main.m中运行如下代码：</p>

<p>``` objc</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@interface Father : NSObject {</p>

<pre><code>int _father;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation Father</p>

<p>@end</p>

<p>@interface Child : Father {</p>

<pre><code>int _child;
</code></pre>

<p>}</p>

<p>@end</p>

<p>@implementation Child</p>

<p>@end</p>

<p>int main(int argc, char * argv[])
{</p>

<p>  Child * child = [[Child alloc] init];  <br/>
  @autoreleasepool {</p>

<pre><code>  // ...
</code></pre>

<p>  }
}
```</p>

<p>我们将断点下在 <code>@autoreleasepool</code> 处，然后在Console中输入<code>p *child</code>,则可以看到Xcode输出如下内容，这与我们上面的说法一致。</p>

<p>```
(lldb) p *child
(Child) $0 = {
  (Father) Father = {</p>

<pre><code>(NSObject) NSObject = {
  (Class) isa = Child
}
(int) _father = 0
</code></pre>

<p>  }
  (int) _child = 0
}
```</p>

<h2>可变与不可变</h2>

<p>因为对象在内存中的排布可以看成一个结构体，该结构体的大小并不能动态变化。所以无法在运行时动态给对象增加成员变量。</p>

<p>相对的，对象的方法定义都保存在类的可变区域中。Objective-C 2.0并未在头文件中将实现暴露出来，但在Objective-C 1.0中，我们可以看到方法的定义列表是一个名为 <code>methodLists</code>的指针的指针（如下图所示）。通过修改该指针指向的指针的值，就可以实现动态地为某一个类增加成员方法。这也是<code>Category</code>实现的原理。同时也说明了为什么<code>Category</code>只可为对象增加成员方法，却不能增加成员变量。</p>

<p><img src="/images/class-objc-class-isa.jpg"></p>

<p>需要特别说明一下，通过<code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code>方法可以变相地给对象增加成员变量，但由于实现机制不一样，所以并不是真正改变了对象的内存结构。</p>

<p>除了对象的方法可以动态修改，因为isa本身也只是一个指针，所以我们也可以在运行时动态地修改isa指针的值，达到替换对象整个行为的目的。不过该应用场景较少。</p>

<h2>系统相关API及应用</h2>

<h3>isa swizzling的应用</h3>

<p>系统提供的KVO的实现，就利用了动态地修改isa指针的值的技术。在<a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/KeyValueObserving/Articles/KVOImplementation.html">苹果的文档</a>中可以看到如下描述：</p>

<p><blockquote><p></p></p><p><p>Key-Value Observing Implementation Details</p></p><p><p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p></p><p><p>The isa pointer, as the name suggests, points to the object's class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p></p><p><p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p></p><p><p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p></p><p><p></p></blockquote></p>

<p><del>类似的，使用isa swizzling的技术的还有系统提供的Key-Value Coding（KVC）。</del> (谢谢大家指出错误，KVC并没有使用到isa swizzling)</p>

<h3>Method Swizzling API说明</h3>

<p>Objective-C提供了以下API来动态替换类方法或实例方法的实现：</p>

<ul>
<li><code>class_replaceMethod</code> 替换类方法的定义</li>
<li><code>method_exchangeImplementations</code> 交换2个方法的实现</li>
<li><code>method_setImplementation</code> 设置1个方法的实现</li>
</ul>


<p>这3个方法有一些细微的差别，给大家介绍如下：</p>

<ul>
<li><code>class_replaceMethod</code>在苹果的文档（如下图所示）中能看到，它有两种不同的行为。当类中没有想替换的原方法时，该方法会调用<code>class_addMethod</code>来为该类增加一个新方法，也因为如此，<code>class_replaceMethod</code>在调用时需要传入<code>types</code>参数，而<code>method_exchangeImplementations</code>和<code>method_setImplementation</code>却不需要。</li>
</ul>


<p><img src="/images/class-replace-method.jpg"></p>

<ul>
<li><code>method_exchangeImplementations</code> 的内部实现其实是调用了2次<code>method_setImplementation</code>方法，从苹果的文档中能清晰地了解到（如下图所示）</li>
</ul>


<p><img src="/images/class-method-exchange-imp.jpg"></p>

<p>从以上的区别我们可以总结出这3个API的使用场景:</p>

<ul>
<li><code>class_replaceMethod</code>, 当需要替换的方法可能有不存在的情况时，可以考虑使用该方法。</li>
<li><code>method_exchangeImplementations</code>，当需要交换2个方法的实现时使用。</li>
<li><code>method_setImplementation</code> 最简单的用法，当仅仅需要为一个方法设置其实现方式时使用。</li>
</ul>


<h3>使用示例</h3>

<p>我们在开发<a href="http://yuantiku.com">猿题库</a>客户端的笔记功能时，需要使用系统的<code>UIImagePickerController</code>。但是，我们发现，在iOS6.0.2系统下，系统提供的<code>UIImagePickerController</code>在iPad横屏下有转屏的Bug，造成其方向错误。具体的Bug详情可以见<a href="http://stackoverflow.com/questions/12522491/crash-on-presenting-uiimagepickercontroller-under-ios-6-0">这里</a>。</p>

<p>为了修复该Bug，我们需要替换<code>UIImagePickerController</code>的如下2个方法</p>

<p>``` objc
- (BOOL)shouldAutorotate;
- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;</p>

<p>```</p>

<p>我们先实现了一个名为<code>ImagePickerReplaceMethodsHolder</code>的类，用于定义替换后的方法和实现。如下所示：</p>

<p>``` objc</p>

<p>// ImagePickerReplaceMethodsHolder.h
@interface ImagePickerReplaceMethodsHolder : NSObject</p>

<ul>
<li>(BOOL)shouldAutorotate;</li>
<li>(UIInterfaceOrientation)preferredInterfaceOrientationForPresentation;</li>
</ul>


<p>@end</p>

<p>// ImagePickerReplaceMethodsHolder.m
@implementation ImagePickerReplaceMethodsHolder</p>

<ul>
<li><p>(BOOL)shouldAutorotate {
  return NO;
}</p></li>
<li><p>(UIInterfaceOrientation)preferredInterfaceOrientationForPresentation {
  return UIInterfaceOrientationPortrait;
}</p></li>
</ul>


<p>@end</p>

<p>```</p>

<p>然后，我们在调用处，判断当前的iOS版本，对于[iOS6.0, iOS6.1)之间的版本，我们将<code>UIImagePickerController</code>的有问题的方法替换。具体代码如下：</p>

<p>``` objc</p>

<h1>define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v)  ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)</h1>

<h1>define SYSTEM_VERSION_LESS_THAN(v)                 ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)</h1>

<ul>
<li><p>(void)load {
  static dispatch_once_t onceToken;
  dispatch_once(&amp;onceToken, ^{</p>

<pre><code>  [self hackForImagePicker];
</code></pre>

<p>  });
}</p></li>
<li><p>(void)hackForImagePicker {
  // fix bug of image picker under iOS 6.0
  // http://stackoverflow.com/questions/12522491/crash-on-presenting-uiimagepickercontroller-under-ios-6-0
  if (SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@"6.0")</p>

<pre><code>  &amp;&amp; SYSTEM_VERSION_LESS_THAN(@"6.1")) {
  Method oldMethod1 = class_getInstanceMethod([UIImagePickerController class], @selector(shouldAutorotate));
  Method newMethod1 = class_getInstanceMethod([ImagePickerReplaceMethodsHolder class], @selector(shouldAutorotate));
  method_setImplementation(oldMethod1, method_getImplementation(newMethod1));

  Method oldMethod2 = class_getInstanceMethod([UIImagePickerController class], @selector(preferredInterfaceOrientationForPresentation));
  Method newMethod2 = class_getInstanceMethod([ImagePickerReplaceMethodsHolder class], @selector(preferredInterfaceOrientationForPresentation));
  method_setImplementation(oldMethod2, method_getImplementation(newMethod2));
</code></pre>

<p>  }
}</p></li>
</ul>


<p>```</p>

<p>通过如上代码，我们就针对iOS特定版本的有问题的系统库函数打了Patch，使问题得到解决。</p>

<h3>开源界的使用</h3>

<p>有少量不明真相的同学以为苹果在审核时会拒绝App使用以上API，这其实是对苹果的误解。使用如上API是安全的。另外，开源界也对以上方法都适当的使用。例如：</p>

<ul>
<li>著名的网络库<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>。AFNetworking网络库(v1.x版本)使用了class_replaceMethod方法（AFHTTPRequestOperation.m文件第105行）</li>
<li><a href="https://github.com/jverkoey/nimbus">Nimbus</a>。Nimbus是著名的工具类库，它在其core模块中提供了<code>NIRuntimeClassModifications.h</code>文件，用于提供上述API的封装。</li>
<li>国内的大众点评iOS客户端。该客户端使用了他们自己开发的基于Wax修改而来的<a href="https://github.com/mmin18/WaxPatch">WaxPatch</a>，WaxPatch可以实现通过服务器更新来动态修改客户端的逻辑。而WaxPatch主要是修改了wax中的wax_instance.m文件，在其中加入了class_replaceMethod来替换原始实现，从而实现修改客户端的原有行为。</li>
</ul>


<h2>总结</h2>

<p>通过本文，我们了解到了Objective-C语言的对象模型，以及Objective-C语言对象模型中对<code>isa swizzling</code>和<code>method swizzling</code>的支持。本文也通过具体的实例代码和开源项目，让我们对该对象模型提供的动态性有了更加深刻的认识。</p>

<h2>后记</h2>

<p>文章发表后，一些同行指出在ARM64的CPU下，isa的内部结构有变化。这点我是知道的，不过希望以后再撰文讨论。感兴趣的同学可以查看苹果今年WWDC2013的视频：《Session 404 Advanced in Objective-C》。</p>

<h3>参考链接</h3>

<ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html</a></li>
<li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html</a></li>
<li><a href="http://www.devalot.com/articles/2011/11/objc-object-model.html">http://www.devalot.com/articles/2011/11/objc-object-model.html</a></li>
<li><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html</a></li>
<li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html</a></li>
<li><a href="http://wwwmain.gnustep.org/resources/downloads.php">gunstep的实现源码</a></li>
<li><a href="http://algorithm.com.au/downloads/talks/objective-c-internals/objective-c-internals.pdf">http://algorithm.com.au/downloads/talks/objective-c-internals/objective-c-internals.pdf</a></li>
<li><a href="http://opensource.apple.com/source/objc4/objc4-532/runtime/">http://opensource.apple.com/source/objc4/objc4-532/runtime/</a></li>
<li><a href="https://github.com/AFNetworking/AFNetworking">https://github.com/AFNetworking/AFNetworking</a></li>
<li><a href="https://github.com/jverkoey/nimbus">https://github.com/jverkoey/nimbus</a></li>
<li><a href="https://github.com/mmin18/WaxPatch">https://github.com/mmin18/WaxPatch</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
