<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 唐巧的技术博客]]></title>
  <link href="http://blog.devtang.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.devtang.com/"/>
  <updated>2012-12-09T15:23:25+08:00</updated>
  <id>http://blog.devtang.com/</id>
  <author>
    <name><![CDATA[唐巧]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于IAP的破解]]></title>
    <link href="http://blog.devtang.com/blog/2012/12/09/iap-crack-issue/"/>
    <updated>2012-12-09T15:06:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/12/09/iap-crack-issue</id>
    <content type="html"><![CDATA[<h3>介绍</h3>

<p>大概在今年7月份，有俄罗斯黑客<a href="http://www.in-appstore.com/">破解</a>了苹果的应用内付费（In-App Purchases），设备在不越狱的情况下就可以免费获得来自苹果官网App Store里应用的收费道具。受影响的产品众多，包括著名的Angry Birds，切水果，Mega Jump, Pandora等。<a href="https://docs.google.com/spreadsheet/ccc?key=0AvSXyNTiqEXMdGRKZlN1Snl5S3h1Z1NsTTFYTlJPTUE#gid=0">这里</a>有一份受影响的著名的游戏应用列表。</p>

<p>正常的越狱行为还是比较复杂的，需要下载破解软件，并且操作进入DFU模式，所以大部分人并不能够方便地越狱。但该方案不需要越狱就可以破解应用内付费，给用户实施该行为提供了方便。</p>

<!-- more -->


<p>为了验证破解的有效性，我今天试了一下，确实能够直接绕开苹果的应用内付费就直接完成购买操作。而苹果也在它的官方文档上<a href="http://developer.apple.com/library/ios/#releasenotes/StoreKit/IAP_ReceiptValidation/_index.html">特别注明</a>了该漏洞的存在，截图如下：</p>

<p><img src="/images/iap-crack-issue.png"></p>

<p>从该文档中我们可以知道，iOS6以下的所有设备（包括越狱或非越狱设备），都会受到该漏洞的影响。</p>

<h3>攻击原理</h3>

<p>我们知道通常的IAP购买行为，从逻辑上就是设备向App Store发起一个购买操作，App Store在验证过用户的密码确认身份后，扣费并返回购买成功的凭证，整个网络操作是通过SSL加密的。</p>

<p>该IAP破解方法，是让设备误以为另一个网站就是AppStore，而向它通讯，而这个假AppStore返回一个假的购买成功的凭证，这样就欺骗设备完成了购买。整个欺骗使用的手段包括：</p>

<ol>
<li>用户给自己添加一个受信任的证书以完成SSL通讯的证书校验</li>
<li>设置一个伪DNS（域名解析服务）地址，把AppStore的域名指向假的地址。</li>
</ol>


<h3>应对措施</h3>

<p>现在看来，暂时有效的应对方法是，将该交易凭证上传到我们自己的服务器上，然后让我们自己的服务器与AppStore进行验证，以确认该凭证是否是伪造的，然后将验证结果返回给设备。苹果的官方网站上也是这么介绍的。这样做麻烦的地方是，对于那些游戏和工具类应用，增加了服务器开发和维护的开销。</p>

<p>但是就象苹果自己也意识到的那样（如下图），既然破解者可以欺骗设备来和AppStore通讯，那么同样破解者从原理上，也可以欺骗设备同我们自己的服务器通讯，到头来，设备本身无论如何是无法知道自己的信息的真实性的。</p>

<p><img src="/images/iap-crack-isuue-2.png"></p>

<p>对于这件事，我们只能期望于：因为我们的应用用户量不大，验证协议又不是通用的，所以破解者需要专门针对我们的通讯协议进行破解，这需要他本身有动力做这个事情，并且要花费他一些时间。所以可能他觉得做这个事情没什么挑战和意义，就不破解我们了。在这件事情上，“希望他不要破解”，好象也是我们唯一能做的事情。</p>

<p>乐观一点讲，AppStore上有上百万的应用，如果所有应用都采用服务器验证购买凭证，黑客一一针对破解，确实也太不可能了，所以这件事情还是很有必要的。另外随着iOS6的普及，该漏洞也将被修补掉，所以大家也不用过于悲观。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS应用内付费(IAP)开发步骤列表]]></title>
    <link href="http://blog.devtang.com/blog/2012/12/09/in-app-purchase-check-list/"/>
    <updated>2012-12-09T12:55:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/12/09/in-app-purchase-check-list</id>
    <content type="html"><![CDATA[<p>前两天和服务端同事一起，完成了应用内付费（以下简称IAP, In app purchase）的开发工作。步骤繁多，在此把开发步骤列表整理如下。因为只是步骤列表，所以并不含详细的说明教程，需要看教程的新手，可以看我附在最后的一些参考链接。</p>

<!-- more -->


<h3>配置Developer.apple.com</h3>

<p>登录到<a href="https://developer.apple.com/">Developer.apple.com</a>，然后进行以下步骤：</p>

<ol>
<li>为应用建立建立一个不带通配符的App ID</li>
<li>用该App ID生成和安装相应的Provisioning Profile文件。</li>
</ol>


<h3>配置iTunes Connect</h3>

<p>登录到<a href="https://itunesconnect.apple.com/">iTunes Connet</a>，然后进行以下步骤：</p>

<ol>
<li>用该App ID创建一个新的应用。</li>
<li><p>在该应用中，创建应用内付费项目，选择付费类型，通常可选的是可重复消费(Consumable)的或是永久有效(Non-Consumable)的2种，然后设置好价格和Product ID以及购买介绍和截图即可，这里的Product ID是需要记住的，后面开发的时候需要。如下图所示：
<img src="/images/iap-add-product-id.png"></p></li>
<li><p>添加一个用于在sandbox付费的测试用户，如下图所示。注意苹果对该测试用户的密码要求
和正式账号一样，必须是至少8位，并且同时包含数字和大小写字母：
<img src="/images/iap-adduser-1.png">
<img src="/images/iap-adduser-2.png"></p></li>
<li><p>填写相关的税务，银行，联系人信息。如下图所示：
<img src="/images/iap-tax-info.png"></p></li>
</ol>


<h3>开发工作(ios端)</h3>

<p>1、 在工程中引入 storekit.framework 和 #import &lt;StoreKit/StoreKit.h></p>

<p>2、 获得所有的付费Product ID列表。这个可以用常量存储在本地，也可以由自己的服务器返回。</p>

<p>3、 制作一个界面，展示所有的应用内付费项目。这些应用内付费项目的价格和介绍信息可以是自己的服务器返回。但如果是不带服务器的单机游戏应用或工具类应用，则可以通过向App Store查询获得。我在测试时发现，向App Store查询速度非常慢，通常需要2-3秒钟，所以不建议这么做，最好还是搞个自己的服务器吧。</p>

<p>4、当用户点击了一个IAP项目，我们先查询用户是否允许应用内付费，如果不允许则不用进行以下步骤了。代码如下：
``` objc</p>

<pre><code>if ([SKPaymentQueue canMakePayments]) {
    // 执行下面提到的第5步：
    [self getProductInfo];
} else {
    NSLog(@"失败，用户禁止应用内付费购买.");
}
</code></pre>

<p>```</p>

<p>5、 我们先通过该IAP的ProductID向AppStore查询，获得SKPayment实例，然后通过SKPaymentQueue的 addPayment方法发起一个购买的操作。
``` objc
// 下面的ProductId应该是事先在itunesConnect中添加好的，已存在的付费项目。否则查询会失败。
- (void)getProductInfo {</p>

<pre><code>NSSet * set = [NSSet setWithArray:@[@"ProductId"]];
SKProductsRequest * request = [[SKProductsRequest alloc] initWithProductIdentifiers:set];
request.delegate = self;
[request start];
</code></pre>

<p>}</p>

<p>// 以上查询的回调函数
- (void)productsRequest:(SKProductsRequest <em>)request didReceiveResponse:(SKProductsResponse </em>)response {</p>

<pre><code>NSArray *myProduct = response.products;
if (myProduct.count == 0) {
    NSLog(@"无法获取产品信息，购买失败。");
    return;
}
SKPayment * payment = [SKPayment paymentWithProduct:myProduct[0]];
[[SKPaymentQueue defaultQueue] addPayment:payment];
</code></pre>

<p>}
```</p>

<p>6、 在viewDidLoad方法中，将购买页面设置成购买的Observer。
``` objc
- (void)viewDidLoad {</p>

<pre><code>[super viewDidLoad];
// 监听购买结果
[[SKPaymentQueue defaultQueue] addTransactionObserver:self];
</code></pre>

<p>}</p>

<ul>
<li>(void)viewDidUnload {
  [super viewDidUnload];
  [[SKPaymentQueue defaultQueue] removeTransactionObserver:self];
}
```</li>
</ul>


<p>7、 当用户购买的操作有结果时，就会触发下面的回调函数，相应进行处理即可。
``` objc
- (void)paymentQueue:(SKPaymentQueue <em>)queue updatedTransactions:(NSArray </em>)transactions {</p>

<pre><code>for (SKPaymentTransaction *transaction in transactions)
{
    switch (transaction.transactionState)
    {
        case SKPaymentTransactionStatePurchased://交易完成
            NSLog(@"transactionIdentifier = %@", transaction.transactionIdentifier);
            [self completeTransaction:transaction];
            break;
        case SKPaymentTransactionStateFailed://交易失败
            [self failedTransaction:transaction];
            break;
        case SKPaymentTransactionStateRestored://已经购买过该商品
            [self restoreTransaction:transaction];
            break;
        case SKPaymentTransactionStatePurchasing:      //商品添加进列表
            NSLog(@"商品添加进列表");
            break;
        default:
            break;
    }
}
</code></pre>

<p>}</p>

<ul>
<li>(void)completeTransaction:(SKPaymentTransaction *)transaction {
  // Your application should implement these two methods.
  NSString * productIdentifier = transaction.payment.productIdentifier;
  NSString * receipt = [transaction.transactionReceipt base64EncodedString];
  if ([productIdentifier length] > 0) {

<pre><code>  // 向自己的服务器验证购买凭证
</code></pre>

<p>  }</p>

<p>  // Remove the transaction from the payment queue.
  [[SKPaymentQueue defaultQueue] finishTransaction: transaction];</p></li>
</ul>


<p>}</p>

<ul>
<li><p>(void)failedTransaction:(SKPaymentTransaction *)transaction {
  if(transaction.error.code != SKErrorPaymentCancelled) {</p>

<pre><code>  NSLog(@"购买失败");
</code></pre>

  } else {

<pre><code>  NSLog(@"用户取消交易");
</code></pre>

<p>  }
  [[SKPaymentQueue defaultQueue] finishTransaction: transaction];
}</p></li>
<li><p>(void)restoreTransaction:(SKPaymentTransaction *)transaction {
  // 对于已购商品，处理恢复购买的逻辑
  [[SKPaymentQueue defaultQueue] finishTransaction: transaction];
}</p></li>
</ul>


<p>```</p>

<p>8、服务器验证凭证(Optional)。如果购买成功，我们需要将凭证发送到服务器上进行验证。考虑到网络异常情况，iOS端的发送凭证操作应该进行持久化，如果程序退出，崩溃或网络异常，可以恢复重试。</p>

<h3>开发工作(服务端)</h3>

<p>服务端的工作比较简单，分4步：</p>

<ol>
<li>接收ios端发过来的购买凭证。</li>
<li>判断凭证是否已经存在或验证过，然后存储该凭证。</li>
<li>将该凭证发送到苹果的服务器验证，并将验证结果返回给客户端。</li>
<li>如果需要，修改用户相应的会员权限。</li>
</ol>


<p>考虑到网络异常情况，服务器的验证应该是一个可恢复的队列，如果网络失败了，应该进行重试。</p>

<p>与苹果的验证接口文档在<a href="https://developer.apple.com/library/ios/#documentation/NetworkingInternet/Conceptual/StoreKitGuide/VerifyingStoreReceipts/VerifyingStoreReceipts.html#//apple_ref/doc/uid/TP40008267-CH104-SW3">这里</a>。简单来说就是将该购买凭证用Base64编码，然后POST给苹果的验证服务器，苹果将验证结果以JSON形式返回。</p>

<p>苹果AppStore线上的购买凭证验证地址是<a href="https://buy.itunes.apple.com/verifyReceipt">https://buy.itunes.apple.com/verifyReceipt</a> ，测试的验证地址是：<a href="https://sandbox.itunes.apple.com/verifyReceipt">https://sandbox.itunes.apple.com/verifyReceipt</a></p>

<h2>参考链接</h2>

<p>以下参考链接详细说明了完成应用内付费开发的步骤：</p>

<ol>
<li><a href="https://developer.apple.com/appstore/in-app-purchase/index.html">https://developer.apple.com/appstore/in-app-purchase/index.html</a></li>
<li><a href="http://www.himigame.com/iphone-cocos2d/550.html">http://www.himigame.com/iphone-cocos2d/550.html</a></li>
<li><a href="http://www.cocoachina.com/iphonedev/sdk/2011/1028/3435.html">http://www.cocoachina.com/iphonedev/sdk/2011/1028/3435.html</a></li>
<li><a href="http://www.cocoachina.com/newbie/basic/2012/0214/3976.html">http://www.cocoachina.com/newbie/basic/2012/0214/3976.html</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用CocoaPods来做iOS程序的包依赖管理]]></title>
    <link href="http://blog.devtang.com/blog/2012/12/02/use-cocoapod-to-manage-ios-lib-dependency/"/>
    <updated>2012-12-02T14:09:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/12/02/use-cocoapod-to-manage-ios-lib-dependency</id>
    <content type="html"><![CDATA[<p><img src="/images/cocoapods-logo.png"></p>

<h2>前言</h2>

<p>每种语言发展到一个阶段，就会出现相应的依赖管理工具, 或者是中央代码仓库。比如</p>

<ul>
<li>Java: maven，Ivy</li>
<li>Ruby: gems</li>
<li>Python: pip, easy_install</li>
<li>Nodejs: npm</li>
</ul>


<p>随着iOS开发者的增多，业界也出现了为iOS程序提供依赖管理的工具，这个工具叫：<a href="http://cocoapods.org/">CocoaPods</a>。</p>

<!-- more -->


<h2>CocoaPods简介</h2>

<p>CocoaPods是一个负责管理iOS项目中第三方开源代码的工具。CocoaPods<a href="https://github.com/CocoaPods/CocoaPods">项目的源码</a>在Github上管理。该项目开始于2011年8月12日，经过一年多的发展，现在已经超过1000次提交，并且持续保持活跃更新。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和更新第三方开源库的时间。</p>

<p>拿我之前开发的粉笔网iPhone客户端为例，其使用了14个第三方开源库。在没有使用CocoaPods以前，我需要：</p>

<ol>
<li>把这些第三方开源库的相关文件复制到项目中，或者设置成git的submodule，然后这些开源库通常需要依赖系统的一些framework，我需要手工地将这些framework一一增加到项目依赖中，比如ASI网络库就需要增加以下framework: CFNetwork, SystemConfiguration, MobileCoreServices, CoreGraphics and zlib。</li>
<li>对于RegexKitLite这个正则表达式库，我还需要设置-licucore的编译参数</li>
<li>手工管理这些依赖包的更新。</li>
</ol>


<p>这些体力活虽然简单，但毫无技术含量并且浪费时间。在使用CocoaPods之后，我只需要将用到的第三方开源库放到一个名为Podfile的文件中，然后执行pod install。CocoaPods就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数。</p>

<h2>CocoaPods的安装和使用介绍</h2>

<h3>安装</h3>

<p>安装方式异常简单, Mac下都自带ruby，使用ruby的gem命令即可下载安装：
<code>bash
$ gem install cocoapods
$ pod setup
</code></p>

<h3>使用</h3>

<p>使用时需要新建一个名为Podfile的文件，以如下格式，将依赖的库名字依次列在文件中即可</p>

<p><code>
platform :ios
pod 'JSONKit',       '~&gt; 1.4'
pod 'Reachability',  '~&gt; 3.0.0'
pod 'ASIHTTPRequest'
pod 'RegexKitLite'
</code></p>

<p>然后你将编辑好的Podfile文件放到你的项目根目录中，执行如下命令即可：
<code>bash
cd "your project home"
pod install
</code></p>

<p>现在，你的所有第三方库都已经下载完成并且设置好了编译参数和依赖，你只需要记住如下2点即可：</p>

<ol>
<li>使用CocoaPods生成的 <em>.xcworkspace 文件来打开工程，而不是以前的 </em>.xcodeproj 文件。</li>
<li>每次更改了Podfile文件，你需要重新执行一次pod install命令。</li>
</ol>


<h3>查找第三方库</h3>

<p>你如果不知道cocoaPods管理的库中，是否有你想要的库，那么你可以通过pod search命令进行查找，以下是我用pod search json查找到的所有可用的库：</p>

<p>``` bash
$ pod search json</p>

<p>-> AnyJSON (0.0.1)
   Encode / Decode JSON by any means possible.
   - Homepage: https://github.com/mattt/AnyJSON
   - Source:   https://github.com/mattt/AnyJSON.git
   - Versions: 0.0.1 [master repo]</p>

<p>-> JSONKit (1.5pre)
   A Very High Performance Objective-C JSON Library.
   - Homepage: https://github.com/johnezang/JSONKit
   - Source:   git://github.com/johnezang/JSONKit.git
   - Versions: 1.5pre, 1.4 [master repo]</p>

<p>-> MTJSONDictionary (0.0.4)
   An NSDictionary category for when you're working with it converting to/from JSON. DEPRECATED, use MTJSONUtils
   instead.
   - Homepage: https://github.com/mysterioustrousers/MTJSONDictionary.git
   - Source:   https://github.com/mysterioustrousers/MTJSONDictionary.git
   - Versions: 0.0.4, 0.0.3, 0.0.2 [master repo]</p>

<p>-> MTJSONUtils (0.1.0)
   An NSObject category for working with JSON.
   - Homepage: https://github.com/mysterioustrousers/MTJSONUtils.git
   - Source:   https://github.com/mysterioustrousers/MTJSONUtils.git
   - Versions: 0.1.0, 0.0.1 [master repo]</p>

<p>-> SBJson (3.1.1)
   This library implements strict JSON parsing and generation in Objective-C.
   - Homepage: http://stig.github.com/json-framework/
   - Source:   https://github.com/stig/json-framework.git
   - Versions: 3.1.1, 3.1, 3.0.4, 2.2.3 [master repo]</p>

<p>-> TouchJSON (1.0)
   TouchJSON is an Objective-C based parser and generator for JSON encoded data.
   - Homepage: https://github.com/TouchCode/TouchJSON
   - Source:   https://github.com/TouchCode/TouchJSON.git
   - Versions: 1.0 [master repo]
```</p>

<h3>生成第三方库的帮助文档</h3>

<p>如果你想让CococaPods帮你生成第三方库的帮助文档，并集成到XCode中，那么用brew安装appledoc即可：</p>

<p><code>bash
brew install appledoc
</code></p>

<p>关于appledoc，我在今年初的另一篇博客<a href="http://blog.devtang.com/blog/2012/02/01/use-appledoc-to-generate-xcode-doc/">《使用Objective-C的文档生成工具:appledoc》</a>中有专门介绍。它最大的优点是可以将帮助文档集成到XCode中，这样你在敲代码的时候，按住opt键单击类名或方法名，就可以显示出相应的帮助文档。</p>

<h2>原理</h2>

<p>大概研究了一下CocoaPods的原理，它是将所有的依赖库都放到另一个名为Pods项目中，然后让主项目依赖Pods项目，这样，源码管理工作都从主项目移到了Pods项目中。发现的一些技术细节有：</p>

<ol>
<li>Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖这个.a文件即可。</li>
<li>对于资源文件，CocoaPods提供了一个名为Pods-resources.sh的bash脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。</li>
<li>CocoaPods通过一个名为Pods.xcconfig的文件来在编译时设置所有的依赖和参数。</li>
</ol>


<p>Have fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[放弃iOS4，拥抱iOS5]]></title>
    <link href="http://blog.devtang.com/blog/2012/11/16/drop-ios4-enbrace-ios5/"/>
    <updated>2012-11-16T20:47:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/11/16/drop-ios4-enbrace-ios5</id>
    <content type="html"><![CDATA[<p><img src="/images/ios5.jpg"></p>

<h2>前言</h2>

<p>苹果在2011年的WWDC大会上发布了iOS5，不过考虑到要支持iOS4.x的系统，大多数App都无法使用iOS5的新特性。现在将近1年半过去了，从我们自己的App后台的统计数据、一些第三方的统计数据和一些业界的朋友告知我的数据都显示，iOS4.x的系统所占比例已经小于5%了，并且还在持续下降。所以，我们有必要放弃对iOS4.x的支持，全面拥抱iOS5。</p>

<p>只支持iOS5.0以上版本使得我们可以使用iOS5带来的诸多新特性，有些新特性可以极大地方便我们的开发，我将这些新特性列举如下。</p>

<!-- more -->


<h2>Storyboard</h2>

<p>Storyboard（故事板）是XCode4和iOS5提供的一个用于控制View Controller之间跳转关系的新概念。你可以把它理解成以前一堆Nib文件的集合。在这个集合里面，每个Nib文件被称作scene（场景），scene之间的跳转关系被称作segue。segue代表着传统的界面间切换的方式，通常是Push方式和Modal方式，当然，你也可以自定义自己的Segue。如下示例图是一个Storyboard的界面：</p>

<p><img src="/images/enbrace-ios5-1.png"></p>

<p>使用Storyboard的好处有以下几点：</p>

<ol>
<li>你可以从storyboard中很方便地梳理出所有View Controller的界面间的调用关系。比如上面那个storyboard示例图，我们就可以很清楚地了解到4个View Controller相互之间是怎么调用的。而这在以前，这些调用关系，都是隐藏在每个View Controller的代码中的，你需要一点一点读代码，才可以将整个调用逻辑整理清楚。</li>
<li>使用Storyboard可以使用Table View Controller的Static Cell功能。简单来说，对于象设置页面等固定内容的TableView，可以直接在Storyboard中通过拖拽就可以设置其界面了，而不是象以前那样需要写一堆table view的delegate和data source回调函数。</li>
<li>通过实现 - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender 方法，每个View Controller的跳转逻辑都聚集在一处，这方便我们统一管理界面跳转和传递数据，这相当于多了一个编程约定。</li>
<li>Storyboard可以方便将一些常用功能模块化和复用。例如WWDC2011年介绍Storyboard的视频就将微博分享功能模块化成一个单独的Storyboard。我在开发App时，也将例如通过第三方注册登录模块做成一个单独的Storyboard，便于以后复用。</li>
</ol>


<p>另外，在iOS6中，storyboard又新增了如exit segue, container view等新功能，这些功能都非常体贴，我们向新的技术方案迁移可以在未来更加方便地使用iOS和XCode的新特性，方便我们的开发。</p>

<p>当然，Storyboard也有它的问题。比如，如果2个人同时编译storyboard，在版本管理中出现冲突时会比较麻烦。虽然storyboard是XML格式的，但是里面的信息有些时候还是不太清晰，当冲突发生时，合并冲突可能会比较麻烦。解决办法是，将Storyboard按功能拆分，每个人尽量负责一个单独的Storyboard，如果实在需要2个人都修改它，避免同时修改。</p>

<h2>ARC</h2>

<p>因为ARC是在编译期做的，所以虽然是与iOS5.0同时推出的Objective-C特性，但是其实ARC是支持iOS4的。只是在iOS4中，不能使用ARC的weak关键字。</p>

<p>由于不需要支持iOS4，我们可以将原本的 __unsafe_unretained 关键字换成weak。这样当这个弱引用对象被回收时，weak指针会被智能地设置成nil，防止“野指针”的产生。</p>

<p>很多人说ARC有这样那样的问题，其实他们是没有真正用好ARC。我在开发粉笔网iPhone客户端时，由于使用了ARC，花三个月开发完的应用，用instruments检测后，没有发现任何内存泄漏问题。这在没有使用ARC的工程中是不可想象的。苹果在推出ARC两年后，今年正式将ARC引入到Mac OS操作系统的SDK中，并且正式将原有的GC deprecated掉，这也说明了ARC技术方案已经是非常成熟的了。</p>

<h2>UIKit</h2>

<p>UIKit在iOS5进行了大量更新。除了新增了如UIStepper控件外，也为以前的控件增加了更多的定制接口。我们可以方便地定义UINavigationBar, UITabBar, UIToolBar等常用控件。</p>

<p>苹果在iOS5中给UIViewController新增加的5方法以及一个属性。关于这个新特性我在<a href="http://blog.devtang.com/blog/2012/02/06/new-methods-in-uiviewcontroller-of-ios5/">这篇文章</a>中详细介绍过。新增的方法主要解决的是让 view的load/unLoad/appear/disappear的相关回调可以传递到子view controller中。</p>

<h2>CoreImage</h2>

<p>苹果从iOS5开始，引入了新的图象类CIImage。CIImage相比以前的UIImage类，更加适合于图象处理和图象分析。</p>

<p>在图象处理方法，苹果内置了CIFilter类，方便开发者对图形进行各种各样的特效处理，在iOS5中，苹果提供了48种Filter，而在iOS6中，内置的Filter达到了93种。可以使用如下代码，查询到当前系统中提供的Filter列表：</p>

<p>``` objc
- (void)logAllFilters {</p>

<pre><code>NSArray * properties = [CIFilter filterNamesInCategory:kCICategoryBuiltIn];
NSLog(@"%@", properties);
for (NSString * filterName in properties) {
    CIFilter * fltr = [CIFilter filterWithName:filterName];
    NSLog(@"%@", [fltr attributes]);
}
</code></pre>

<p>}
```</p>

<p>这些内置的Filter在分类上，包括：</p>

<ol>
<li>颜色效果类。例如黄昏效果，曝光度调整等。</li>
<li>组合效果类。把2张图片按各种规则混合成一张图。</li>
<li>几何变形类。例如把照片倾斜或者翻转。</li>
<li>重复效果类。如平铺，折叠，镜象等。</li>
<li>失真扭曲类。如把图片中心做成漩涡效果等。</li>
<li>模糊和锐化类。</li>
<li>Stylize效果。</li>
<li>Halftone效果。</li>
</ol>


<p>以上所有效果可以叠加作用在一起，最终你可以创造出自己的图片处理效果。最终你可以通过CIContext，将处理过的CIImage转换成UIImage输出。有了Core Image，你可以方便地开发图象处理相关的应用，而不用关心图象处理算法的细节。</p>

<h2>NSJSONSerialization</h2>

<p>在我的<a href="http://blog.devtang.com/blog/2012/05/05/do-not-use-sbjson/">《不要使用SBJSON(json-framework)》</a> 一文中，我提到了关于JSON解析库的性能测试。测试结果表明，苹果从iOS5开始提供的 <a href="http://developer.apple.com/library/ios/#documentation/Foundation/Reference/NSJSONSerialization_Class/Reference/Reference.html#//apple_ref/doc/uid/TP40010946">NSJSONSerialization</a> 类有着最好的性能表现。所以，从iOS5以后，你可以扔掉那些第三方JSON解析库了。</p>

<h2>ViewController切换</h2>

<p>iOS提供了如下新的接口来切换ViewController，而以前的presentModalViewController和dismissModalViewControllerAnimated被Deprecated掉了。</p>

<p>``` objc
// 新的接口
- (void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (<sup>)(void))completion;</sup>
- (void)dismissViewControllerAnimated: (BOOL)flag completion: (void (<sup>)(void))completion;</sup></p>

<p>// 被Deprecated的接口
- (void)presentModalViewController:(UIViewController *)modalViewController animated:(BOOL)animated;
- (void)dismissModalViewControllerAnimated:(BOOL)animated;
```</p>

<p>新接口的差别是提供了一个completion参数，允许你传入一个block，来定义该操作结束时的回调。使用新的函数后，可以方便同时Dismiss或Present多个View Controller，也可以方便做多个UI效果之间的衔接。</p>

<h2>其它</h2>

<p>GameKit, Core Data, NewsstandKit, GLKit在iOS5中都有更新。可惜我都没有具体使用过，所以不便做更多介绍。</p>

<p>Have fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让XCode的 stack trace信息可读]]></title>
    <link href="http://blog.devtang.com/blog/2012/11/14/make-stack-trace-more-readable/"/>
    <updated>2012-11-14T20:19:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/11/14/make-stack-trace-more-readable</id>
    <content type="html"><![CDATA[<p>昨天在写iOS代码的时候，调试的时候模拟器崩溃了。异常停在了如下整个main函数的入口处：</p>

<p>``` objc
int main(int argc, char *argv[])
{</p>

<pre><code>@autoreleasepool {
    // 异常停在了下面这行，毫无提示作用
    return UIApplicationMain(argc, argv, nil, NSStringFromClass([MyClass class]));
}
</code></pre>

<p>}</p>

<p>```</p>

<!-- more -->


<p>XCode的Console界面报出了一些出错信息, 如下图所示：</p>

<p><img src="/images/stacktrace-1.jpg"></p>

<p>我根据Console里面的文字提示信息，猜出应该是出现了空指针nil的操作。但是具体出错在哪一行，却不知道。最终虽然找到了bug，但是debug的过程确实费了些时间。考虑到这个stace trace信息应该对我挺有帮助才对的，所以我就查了一下如何让这原本一堆16进制的调用栈信息更可读。于是在stackoverflow上找到了2个比较好的解决办法，在这里分享给大家。</p>

<h2>方法一</h2>

<p>该<a href="http://stackoverflow.com/questions/7841610/xcode-4-2-debug-doesnt-symbolicate-stack-call">方法</a>的步骤是，首先在你的AppDelegate中定义一个方法, 用于处理异常：</p>

<p>``` objc
void uncaughtExceptionHandler(NSException *exception) {</p>

<pre><code>NSLog(@"CRASH: %@", exception);
NSLog(@"Stack Trace: %@", [exception callStackSymbols]);
// Internal error reporting
</code></pre>

<p>}
```
然后在应用启动时，设置这个方法作为自己的自定义异常回调：</p>

<p>``` objc
- (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{</p>

<pre><code>NSSetUncaughtExceptionHandler(&amp;uncaughtExceptionHandler);
// Normal launch stuff
</code></pre>

<p>}
```</p>

<p>完成之后，当对于上面的异常，在定义了这个回调之后，Log信息变成如下所示，出错行一目了然，根据下面的可读的stack trace，我一下就可以找到是QuestionParser这个类的第378行导致的异常，进而可以跳到出错行分析原因，很容易就把bug修复了。</p>

<p>``` objc
Ape[2711:11303] CRASH: *** -[__NSPlaceholderDictionary initWithObjects:forKeys:count:]: attempt to insert nil object from objects[2]
Ape[2711:11303] Stack Trace: (</p>

<pre><code>0   CoreFoundation                      0x0209402e __exceptionPreprocess + 206
1   libobjc.A.dylib                     0x01a71e7e objc_exception_throw + 44
2   CoreFoundation                      0x0205aa95 -[__NSPlaceholderDictionary initWithObjects:forKeys:count:] + 165
3   CoreFoundation                      0x020874e9 +[NSDictionary dictionaryWithObjects:forKeys:count:] + 73
4   Ape                                 0x00096a0a +[QuestionParser parseToDictionary:] + 378
5   Ape                                 0x00096434 -[QuestionStore putQuestion:] + 308
6   Ape                                 0x00089ddf -[QuestionViewController requestFinished:] + 303
7   Ape                                 0x000869dd -[NetworkAgent requestFinished:] + 653
8   Ape                                 0x00085d33 __27-[NetworkAgent addRequest:]_block_invoke_0 + 131
9   libdispatch.dylib                   0x01cf153f _dispatch_call_block_and_release + 15
10  libdispatch.dylib                   0x01d03014 _dispatch_client_callout + 14
11  libdispatch.dylib                   0x01cf2fd6 _dispatch_after_timer_callback + 28
12  libdispatch.dylib                   0x01d03014 _dispatch_client_callout + 14
13  libdispatch.dylib                   0x01cfa8b7 _dispatch_source_latch_and_call + 219
14  libdispatch.dylib                   0x01cf6405 _dispatch_source_invoke + 322
15  libdispatch.dylib                   0x01cf3768 _dispatch_main_queue_callback_4CF + 187
16  CoreFoundation                      0x0203aaf5 __CFRunLoopRun + 1925
17  CoreFoundation                      0x02039f44 CFRunLoopRunSpecific + 276
18  CoreFoundation                      0x02039e1b CFRunLoopRunInMode + 123
19  GraphicsServices                    0x0282b7e3 GSEventRunModal + 88
20  GraphicsServices                    0x0282b668 GSEventRun + 104
21  UIKit                               0x00be265c UIApplicationMain + 1211
22  Ape                                 0x00016c5d main + 141
23  Ape                                 0x00002b05 start + 53
24  ???                                 0x00000001 0x0 + 1
</code></pre>

<p>)</p>

<p>```</p>

<h2>方法二</h2>

<p>方法二相比方法一更加简单，具体做法是在XCode界面中按cmd + 6跳到Breakpoint的tab，然后点击左下角的+号，增加一个Exception的断点，如下图所示。这样，当异常出现时，会自动停在异常处，而不会抛出到UIApplicationMain。拿我的有bug的程序来说，代码会自动断在QuestionParser这个类的第378行。</p>

<p><img src="/images/stacktrace-2.png"></p>

<h2>总结</h2>

<p>其实以前XCode是能显示出可读的stack trace信息的，似乎到了XCode4.2以后就出问题了。所以上面提到的2个办法相当于walk around解决了XCode4.2以后出现的bug。如果该文章对你有用，希望你能帮我点击下面的分享按钮，分享给更多朋友，同时也帮我宣传一下博客，这将有助于我分享更多的心得给大家，Have fun!</p>
]]></content>
  </entry>
  
</feed>
