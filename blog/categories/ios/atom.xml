<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 唐巧的技术博客]]></title>
  <link href="http://blog.devtang.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.devtang.com/"/>
  <updated>2013-03-27T21:45:55+08:00</updated>
  <id>http://blog.devtang.com/</id>
  <author>
    <name><![CDATA[唐巧]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[是否应该使用ARC?]]></title>
    <link href="http://blog.devtang.com/blog/2013/03/27/should-we-use-arc/"/>
    <updated>2013-03-27T21:23:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/03/27/should-we-use-arc</id>
    <content type="html"><![CDATA[<p><img src="/images/arc-logo.jpg"></p>

<p>我和身边做iOS开发的同事组建了一个QQ群，每隔一段时间，大家就会讨论是否应该使用ARC。所以我觉得有必要将这些讨论分享出来，让大家消除对于ARC的疑虑。</p>

<!-- more -->


<p>关于ARC的介绍文章网上已经很多，苹果的官方文档也不少。担心使用ARC会带来问题的同学主要的理由有以下5点:</p>

<ol>
<li>担心这个技术方案不靠谱。苹果大多数时候的技术方案都是比较靠谱的，但也有一些技术方案有很多坑，例如storyboard。关于storyboard的问题可以参看我的<a href="http://blog.devtang.com/blog/2012/12/15/do-not-use-storyboard/">这篇文章</a>。</li>
<li>原有的项目在非ARC环境下运行良好，担心迁移成本或引入新的问题。</li>
<li>苹果以前手工管理内存需要非常小心，稍微不注意应用程序就崩溃了。有过这段经历的iOS开发老手，心里上还是觉得自己手工管理内存更踏实一些。</li>
<li>使用ARC需要了解ARC的一些细节，还需要引入_bridge等新的关键字，学习成本还是有的。</li>
<li>以为ARC只能支持iOS5.0以上（这是非常大的误解）。</li>
</ol>


<p>对于上面提到5点问题，我认为相应的回答如下:</p>

<ol>
<li>ARC是WWDC2011大会时提出的技术，离现在已经快2年了，而且苹果现在将MacOS上的垃圾回收机制废弃(Deprecated)，采用ARC替代，无疑证明了ARC是成熟的了。</li>
<li>确实有一些迁移成本，但苹果在Xcode中专门集成了迁移工具，成本已经非常小了。如下图就是Xcode集成的将非ARC工程转换成ARC工程的工具。另外，为了兼容第三方的非ARC开源库，你也可以在工程中随意使用编译参数：<code>-fno-objc-arc</code> ,这个参数允许对部分文件关闭ARC。</li>
<li>手工管理内存虽然踏实，但是泄露很容易发生。常常开发完成后，需要使用Instruments来检测泄露。但用了ARC后，基本不会出现泄露了，我在开发粉笔网iPhone客户端时，由于使用了ARC，花三个月开发完的应用，用instruments检测后，没有发现任何内存泄漏问题。这在没有使用ARC的工程中是不可想象的。</li>
<li>确实有学习成本。但是非常值得学习，能省不少开发精力。</li>
<li><p>虽然ARC是与iOS5一同推出，但是由于ARC的实现机制是在编译期完成，所以使用ARC之后App仍然可以支持iOS4.3。稍微需要注意的是，如果要在ARC开启的情况下支持iOS4.3，需要将weak关键字换成 __unsafe_unretained，另外还有一些细节需要处理，在这里我就不展开说了。</p>

<p><img src="/images/xcode-convert-to-arc.jpg"></p></li>
</ol>


<p>所以，希望大家都能在项目中使用ARC，一旦你感受到它带来的好处，你就离不开它了。它也能让你从繁琐的内存管理代码中解放出来，将精力更多关注于代码结构、设计模式而不是底层的内存管理。</p>

<p>关于ARC的教程，除了苹果的官方文档外，推荐易飞杨写的<a href="http://www.yifeiyang.net/category/embedded/iphone-embedded/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/arc/">ARC相关的文章</a>。易飞杨的博客中关于iPhone开发的文章都写得很深入，值得好好阅读。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分享iOS开发技巧的微信公共账号]]></title>
    <link href="http://blog.devtang.com/blog/2013/02/21/introduction-of-weixin-public-account/"/>
    <updated>2013-02-21T20:02:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/02/21/introduction-of-weixin-public-account</id>
    <content type="html"><![CDATA[<p><img src="http://blog.devtang.com/images/weixin-why.png" width="300px" /></p>

<p>记得我以前刚学iOS开发的时候，常常会遇到各种问题，身边没有人交流，遇到问题只能上网搜。虽然stackoverflow能解决大部分问题，但是还是很渴望和身边的一些同行进行讨论和交流。</p>

<p>后来，我组建了一个QQ群，尽力把自己通过各种渠道认识的iOS同行聚集到群里面，希望形成一个讨论环境。现在群里面加入了包括网易，腾讯，百度，新浪，搜狐，美团，豆瓣等公司的iOS程序员以及一些自由职业者。因为大家都是比较有经验的开发者，所以每天大家的讨论不太多，但是都很有价值。</p>

<!-- more -->


<p>但是，我发现QQ群对于讨论的归档性太弱。很多有代表意义的讨论，对于其他人可能是有用的，但是由于群的归档性太差，随着时间流逝，这些信息无法被有效沉淀。</p>

<p>所以我想做一个尝试。我想把这个QQ群里面有价值的讨论信息整理归档到这个公共账号上。希望大部分iOS同行每天都能得到少量的，但是有价值的信息。对于特别有价值的信息，我也会在后期整理成博客，发表在博客上。</p>

<p>希望这能对你平时的工作有所帮助。</p>

<p>如果你感兴趣，那么可以扫描以下二维码加该账号为好友，或者在微信中搜索“iOS开发”。</p>

<p><img src="/images/weixin-qr.jpg"></p>

<hr>


<h1>后记（2013年3月27日）</h1>

<h3>微信公共账号的运营感受</h3>

<p>上面的提到的公共账号，我尝试运营了半个月，有如下感受：</p>

<ol>
<li>微信公共平台实时性太高，文章归档性弱，微信4.5才增加查看所有历史消息的功能，而且很多人还不知道从哪儿查看历史消息。</li>
<li>微信公共平台相对微博或RSS订阅，对订阅人的干扰强度更大。因为消息会实时推送到订阅人手机上，并且有消息收到提醒。</li>
<li>微信公共平台上的消息因为是在手机上阅读，不适合作长篇的，深度的技术讲解，但适合作简单入门的技术介绍</li>
<li>微信公共平台的后台管理太弱，不适宜代码的排版。</li>
<li>微信公共平台上的消息不能被搜索引擎检索，阻碍了有价值的信息的传播。</li>
</ol>


<p>综上所述，微信公共平台更适合于发表新闻类或漫谈的文章（例如Fenng的小道消息），或者入门性技术介绍（例如池建强的Mac技巧）。不适合长篇的技术深入讨论，更不适合贴代码，也不适合归档文章（要归档得自己另外整理）。</p>

<p>另外，每天通过公共账号发表文章相当费时间精力，至少需要1个小时的时间。对于我这个身处于创业公司的人来说，实在没有那么多时间花在这上面。所以现在该公共账号已经基本处于停止更新状态。</p>

<h3>如何申请加群？</h3>

<p>有很多朋友留言问我们的QQ群号并想申请加入，在此我统一回复一下。</p>

<p>QQ群由于实时性太强，所以一旦有讨论，就会对平时的工作造成影响。所以QQ群里面的讨论不应该太热烈，否则每天就没法干活了。</p>

<p>所以我希望群里面的人都足够精通iOS开发，对于在群里面提出来的问题，都是值得讨论的问题。通过讨论，大家都有了收获，才不致于觉得这个群太打扰而把它屏蔽掉。</p>

<p>因此，我不希望群里面加太多的人，现在人数基本上有讨论的气氛，对于技术问题的讨论也都会有结果。所以，<font color="red">暂时不接受任何加群申请。</font></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设置应用内的系统控件语言]]></title>
    <link href="http://blog.devtang.com/blog/2013/01/23/set-ios-system-ui-language/"/>
    <updated>2013-01-23T21:05:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/01/23/set-ios-system-ui-language</id>
    <content type="html"><![CDATA[<p><img src="/images/bdj-rank.jpg"></p>

<p>在iOS应用中，有时候会需要调用系统的一些UI控件，例如：</p>

<ol>
<li>在UIWebView中长按会弹出系统的上下文菜单</li>
<li>在UIImagePickerController中会使用系统的照相机界面</li>
<li>在编译状态下的UITableViewCell，处于待删除时，会有一个系统的删除按钮。</li>
</ol>


<p>以上这些UI控件中，其显示的语言并不是和你当前手机的系统语言一致的。而是根据你的App内部的语言设置来显示。结果就是，如果你没有设置恰当的话，你的中文App可能会出现一些英文的控件文字。</p>

<!-- more -->


<p>例如下图中，一个名为“百思不得姐”的应用，其在AppStore免费总榜中排名前100，图书类分类榜排名第一的应用，就闹出了系统控件显示成了英文的笑话，在其软件界面中长按，就会出如下的菜单，可以看到，这个菜单的文字全是英文的：</p>

<p><img src="/images/ios-menu-1.jpg"></p>

<p>而正常的菜单应该是中文的，如下是新浪微博的正文长按之后的效果：</p>

<p><img src="/images/ios-menu-2.jpg"></p>

<p>如何解决这个问题呢？方法如下:</p>

<p>用vim直接打开工程的Info.plist文件，在文件中增加如下内容即可：</p>

<p>``` xml
   <key>CFBundleLocalizations</key>     <br/>
   <array></p>

<pre><code>       &lt;string&gt;zh_CN&lt;/string&gt;
       &lt;string&gt;en&lt;/string&gt;
</code></pre>

<p>   </array>
```</p>

<p>TO: 百思不得姐的开发者，不用谢：）你们应用的内容挺有意思的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈ObjC对象的两段构造模式]]></title>
    <link href="http://blog.devtang.com/blog/2013/01/13/two-stage-creation-on-cocoa/"/>
    <updated>2013-01-13T10:15:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/01/13/two-stage-creation-on-cocoa</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>Objective-c语言在申请对象的时，需要使用两段构造(<a href="http://volonbolon.net/post/634999801/two-stage-creation-in-cocoa">Two Stage Creation</a>)的模式。一个对象的创建，需要先调用alloc方法或allocWithZone方法，再调用init方法或initWithSomething方法。如下是一个NSString对象的创建示例：</p>

<p><code>objc
NSString * str = [[NSString alloc] initWithString:@"http://blog.devtang.com"];
</code></p>

<p>由于该语言的对象创建方法和大多数其它语言（如C、C++、Java、JavaScript）都不一样，所以引起了我的好奇。是什么原因促使Objective-C做了这种设计，而又是什么原因促使大多数其它语言都采用"new"方法来一次性创建对象呢？</p>

<p>在看了<a href="http://www.amazon.com/Cocoa-Design-Patterns-Erik-Buck/dp/0321535022">《Cocoa Design Patterns》</a>一书（顺便吐槽一下该书中文版翻译质量不高，建议看英文版），并且做了一些调研之后，我将总结分享给大家，欢迎大家讨论。</p>

<!-- more -->


<h2>对象的创建</h2>

<p>我们先来看看在对象的创建过程中，alloc和init到底做了哪些事情。</p>

<h3>alloc方法</h3>

<p>根据苹果的<a href="https://developer.apple.com/library/mac/#documentation/cocoa/conceptual/CocoaFundamentals/CocoaObjects/CocoaObjects.html#//apple_ref/doc/uid/TP40002974-CH4-SW54">官方文档</a>。当对象创建时，cocoa会从应用程序的虚拟地址空间上为该对象分配足够的内存。cocoa会遍历该对象所有的成员变量，通过成员变量的类型来计算所需占用的内存。</p>

<p>当我们通过alloc或allocWithZone方法创建对象时，cocoa会返回一个未”初使化“过的对象。在这个过程中，cocoa除了上面提到的申请了一块足够大的内存外，还做了以下3件事：</p>

<ol>
<li>将该新对象的引用计数(Retain Count)设置成1。</li>
<li>将该新对象的isa成员变量指向它的类对象。</li>
<li>将该新对象的所有其它成员变量的值设置成零。（根据成员变量类型，零有可能是指nil或Nil或0.0）</li>
</ol>


<p>isa成员变量是在<a href="https://developer.apple.com/library/mac/#documentation/cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/cl/NSObject">NSObject</a>中定义的，所以保证Cocoa的所有对象都带有此成员变量。借助该变量可以实现Cocoa对象在运行时的自省(Introspection)功能。</p>

<h3>init方法</h3>

<p>大部分情况下，我们都不希望所有成员变量都是零，所以init方法会做真正的初使化工作，让对象的成员变量的值符合我们程序逻辑中的初始化状态。例如，NSMutableString可能就会额外再申请一块字符数组，用于动态修改字符串。</p>

<p>init还有一个需要注意的问题。某些情况下，init会造成alloc的原本空间不够用，而第二次分配内存空间。所以下面的写法是错的：</p>

<p><code>objc
NSString * s = [NSString alloc];
[s init]; // 这儿init返回的地址可能会变。s原本的指针地址可能是无效的地址。
</code></p>

<p>为此，苹果引入了一个编程规范，让大家写的时候将alloc 和init写在一行。所以上面的代码正确的写法是</p>

<p><code>objc
NSString * s = [[NSString alloc] init];
</code></p>

<h3>new</h3>

<p>在后来，苹果也引入了类方法：new。但是由于历史原因，init方法是实例方法而非类方法，所以作为类方法的new，只能简单地等价于 alloc + init，不能指定init的参数，所以用处不大。苹果在设计上也禁止多次调用init方法，例如如下代码会抛出 NSInvalidArgumentException。</p>

<p><code>objc
NSString * str = [NSString new];
str = [str initWithString:@"Bar"];
</code></p>

<h2>为什么这么设计</h2>

<p>说回来文章开始时提出来问题，为什么苹果要这么设计而其它语言不这么设计？</p>

<p>上面提到，alloc其实不只干了申请内存的事情，还做了：
 1. 内存管理的事情，设置Retain Count。
 2. 运行时自省的功能，设置isa变量。
 3. 非逻辑性的初使化功能，设置所有成员变量为零。</p>

<p>简单看来，根据设计模式的Single Responsibility的设计原则，苹果觉得alloc和init是做的2件不同的事情，把这两件事情分开放在2个函数中，对于程序员更加清楚明了。更详细查阅文档后，我觉得这是由于历史原因，让苹果觉得alloc方法过于复杂，在历史上，alloc不仅仅是分配内存，还可以详细的指定该内存所在的内存分区（用NSZone表示）。这就是下面要提到的allocWithZone方法。</p>

<p>在<a href="http://www.amazon.com/Cocoa-Design-Patterns-Erik-Buck/dp/0321535022">《Cocoa Design Patterns》</a>一书也提到，早期苹果是建议程序员使用 allocWithZone来管理内存分配的，每个NSZone表示一块内存分区，allowWithZone方法可以允许对象从指定分区分配内存。了解到这段历史后，也不难理解苹果这么设计的原因了。因为在这种情况下，alloc要处理的情况复杂，和init放到一起不合适。</p>

<p>而对于大多数出生在90年代的语言来说(例如Java,JavaScript,C#)，由于内存具体的分配方案都不需要程序员操心了，所以就不需要单独为内存分配实现一个alloc方法了。</p>

<h2>后记</h2>

<h3>allocWithZone被废弃</h3>

<p>自从Mac OS X 10.5上引入了垃圾回收机制后，苹果就不建议程序员使用allocWithZone了，事实上，cocoa框架也会忽略allocWithZone指定的分区。苹果在文档中也<a href="https://developer.apple.com/library/mac/#documentation/cocoa/Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/clm/NSObject/allocWithZone:">提到</a>，allocWithZone仅仅是一个历史遗留设计了。下图是苹果的文档截图：</p>

<p><img src="/images/allocWithZone.png" title="" ></p>

<h3>Objective-C的历史</h3>

<p>Objective-C是一门非常老的语言。如果你查阅文档，你会发现它和C++出生在同一时代（两种语言的发行年份都是<a href="http://en.wikipedia.org/wiki/Stepstone">1983年</a>），都是作为C语言的面向对象的接班人被推出。当然，最终C++胜出。由于历史久远，Objective-C也无法有太多优秀的语言做参考，所以，有很多历史遗留的设计。在2007年苹果公司发布了Obj-C 2.0, 对其进行了大量改进。</p>

<p>在最近几年的WWDC大会上，每年苹果都会对Objective-C和其对应的LLVM编译器进行改进，例如WWDC2011推出的ARC，WWDC2012推出的Object Literals等。所以现在使用Objective-C做开发已经非常舒服了。期待苹果给开发者带来更多惊喜。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在iOS中使用ZXing库]]></title>
    <link href="http://blog.devtang.com/blog/2012/12/23/use-zxing-library/"/>
    <updated>2012-12-23T17:03:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2012/12/23/use-zxing-library</id>
    <content type="html"><![CDATA[<p><img src="/images/zxing-icon.png"></p>

<h2>前言</h2>

<p><a href="https://code.google.com/p/zxing/">ZXing</a>(<a href="https://github.com/zxing/zxing">Github镜像地址</a>)是一个开源的条码生成和扫描库（开源协议为<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache2.0</a>)。它不但支持众多的条码格式，而且有各种语言的实现版本，它支持的语言包括：Java, C++, C#, Objective-C, ActionScript和Ruby。</p>

<p>我上周在iOS项目开发中使用了ZXing的扫描二维码功能。在此总结一下如何将ZXing集成到已有的iOS工程中，分享给大家。</p>

<!-- more -->


<h2>集成步骤</h2>

<p>首先去Google Code或Github将ZXing的代码下载下来，整个工程比较大，我们只需要其中涉及iOS的部分，所以最好做一些裁剪。简单来说，我们只需要保留cpp和iphone这2个文件夹，其余的全部删掉。如下图所示：</p>

<p><img src="/images/zxing-step-1.png"></p>

<p>接着我们继续裁剪，对于cpp这个目录，只保留cpp/core/src/zxing下面的内容，其余内容也可以删掉了。但是整个目录结构必须保持原样。裁剪完后，整个目录结构如下所示：</p>

<p><img src="/images/zxing-step-2.png"></p>

<p>接下来，我们把裁剪后的zxing目录整个移动到我们的iOS项目的目录下，并且把上图中可以看到的ZXingWidget.xcodeproj文件拖动到我们的iOS工程中。</p>

<p>下一步，我们需要设置ZXing项目和我们原本的iOS项目之间的依赖关系。在我们的iOS项目的设置中，点击build phases tab，然后增加 Target Dependencies 和 Link binary，并且增加这些framework依赖：</p>

<pre><code>a. AVFoundation
b. AudioToolbox
c. CoreVideo
d. CoreMedia
e. libiconv
f. AddressBook
g. AddressBookUI
</code></pre>

<p>完成之后如下图所示：</p>

<p><img src="/images/zxing-step-3.png"></p>

<p>最后一步，在设置中增加如下2个header search path:</p>

<ul>
<li>./zxing/iphone/ZXingWidget/Classes</li>
<li>./zxing/cpp/core/src</li>
</ul>


<p>需要注意的是，第一个path要设置成循环查找子目录，而第二个不循环查找，如下图所示：</p>

<p><img src="/images/zxing-step-4.png"></p>

<p>恭喜你，完成这步之后，你就已经完成ZXing库的集成了。下面谈谈如何使用ZXing库来做二维码识别。</p>

<h2>二维码识别</h2>

<p>ZXing的iOS版本提供2种方法来做二维码识别功能，第一种方法比较简单，第二种方法比较复杂。我在做Demo时使用了第一种方法，做真正项目开发的时候使用了第二种方法，所以都给大家介绍一下。</p>

<h3>使用方法一</h3>

<p>ZXing直接提供了一个扫描二维码的View Controller，即ZXingWidgetController。在需要使用的界面代码中，加入文件依赖：</p>

<p>``` objc</p>

<h1>import &lt;ZXingWidgetController.h></h1>

<h1>import &lt;QRCodeReader.h></h1>

<p><code>
然后在需要扫描的时候，调用如下代码即可：
</code> objc
- (IBAction)scanPressed:(id)sender {
  ZXingWidgetController <em>widController = [[ZXingWidgetController alloc] initWithDelegate:self showCancel:YES OneDMode:NO];
  NSMutableSet </em>readers = [[NSMutableSet alloc ] init];
  QRCodeReader* qrcodeReader = [[QRCodeReader alloc] init];
  [readers addObject:qrcodeReader];
  [qrcodeReader release];
  widController.readers = readers;
  [readers release];
  [self presentModalViewController:widController animated:YES];
  [widController release];
}
```</p>

<p>在ZXing扫描有结果时，会调用如下回调函数：</p>

<p>``` objc</p>

<p>@protocol ZXingDelegate
- (void)zxingController:(ZXingWidgetController<em>)controller didScanResult:(NSString </em>)result;
- (void)zxingControllerDidCancel:(ZXingWidgetController*)controller;
@end</p>

<p>```</p>

<h3>使用方法二</h3>

<p>方法二与方法一的区别就相当于AVFoundation和UIImagePickerController的区别一样。简单来说，就是使用方法二比方法一更加麻烦，但是获得的可定制性更高。</p>

<p>使用方法二时，你需要自己用AVFoundation获得Camera返回的实时图象，然后转成UIImage，最后传给ZXing的Decoder类完成二维码的识别。由于使用AVFoundation涉及的代码略多，我写的示意代码如下：</p>

<p>``` objc</p>

<h1>import "Decoder.h"</h1>

<h1>import "TwoDDecoderResult.h"</h1>

<h1>import "QRCodeReader.h"</h1>

<ul>
<li>(void)viewDidLoad {
  // setup QR reader
  self.qrReader = [[NSMutableSet alloc ] init];
  QRCodeReader* qrcodeReader = [[QRCodeReader alloc] init];
  [self.qrReader addObject:qrcodeReader];
  self.scanningQR = NO;
  self.step = STEP_QR;
}</li>
</ul>


<p>// AVFoundation的回调函数
- (void)captureOutput:(AVCaptureOutput <em>)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection </em>)connection {</p>

<pre><code>// 第一步，将sampleBuffer转成UIImage
UIImage *image= [self getCaptureImage:sampleBuffer];
// 第二步，用Decoder识别图象
Decoder *d = [[Decoder alloc] init];
d.readers = self.qrReader;
d.delegate = self;
self.scanningQR = [d decodeImage:image] == YES ? NO : YES;
</code></pre>

<p>}
```</p>

<p>ZXing的Decoder类提供了以下回调函数获得识别结果：</p>

<p>``` objc
@protocol DecoderDelegate<NSObject>
@optional
- (void)decoder:(Decoder <em>)decoder willDecodeImage:(UIImage </em>)image usingSubset:(UIImage <em>)subset;
- (void)decoder:(Decoder </em>)decoder didDecodeImage:(UIImage <em>)image usingSubset:(UIImage </em>)subset withResult:(TwoDDecoderResult *)result {</p>

<pre><code>NSLog(@"result = %@", [result text]);
</code></pre>

<p>}
- (void)decoder:(Decoder <em>)decoder failedToDecodeImage:(UIImage </em>)image usingSubset:(UIImage <em>)subset reason:(NSString </em>)reason;
- (void)decoder:(Decoder *)decoder foundPossibleResultPoint:(CGPoint)point;</p>

<p>@end</p>

<p>```</p>

<h2>Trouble Shoot &amp; Tips</h2>

<p>我在使用中遇到了一些问题，主要是编译的问题。</p>

<ol>
<li>一个是找不到 <iostream> 头文件。解决方法：把用到ZXing的源文件扩展名由.m改成.mm。</li>
<li>报错：Undefined symbols for architecture armv7s，<a href="http://stackoverflow.com/questions/12968369/undefined-symbols-for-architecture-armv7-when-using-zxing-library-in-xcode-4-5">解决方法</a>：把ZXingWidget的一个build target参数："Build Active Architecture Only" 修改成 "NO".</li>
<li>报错：No such file or directory，出现该错误可能是你的Header Search Path写错了，或者就是你的zxing库的目录结构不是我上面强调的，好好检查一下吧。</li>
<li>如果你需要生成二维码做测试，推荐一个不错的在线生成二维码的网站：<a href="http://cli.im/">http://cli.im/</a></li>
</ol>


<h2>ZXing和OpenCV的兼容问题</h2>

<p>ZXing 2.1 和OpenCV 2.4.3的iOS库有一些兼容问题，他们对C++标准库的版本和编译器版本都有一些需求，造成满足一方了，另一方就编译不通过了。Stackoverflow上有人终于找到了一个让它们和平共处的方法，但是只适用于iOS5.0以上版本。正好我们的App只支持iOS5.0+，所以就搞定了。所以如果你也正好遇到这个问题，可以参考<a href="http://stackoverflow.com/questions/13498581/opencv-zxing-incompatibility-on-ios">这个贴子</a>。</p>

<p>希望本文对大家有用，Have Fun~</p>
]]></content>
  </entry>
  
</feed>
