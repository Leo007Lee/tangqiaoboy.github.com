<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 唐巧的技术博客]]></title>
  <link href="http://blog.devtang.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.devtang.com/"/>
  <updated>2013-06-17T22:06:43+08:00</updated>
  <id>http://blog.devtang.com/</id>
  <author>
    <name><![CDATA[唐巧]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS开发工具篇-AppStore统计工具]]></title>
    <link href="http://blog.devtang.com/blog/2013/06/16/ios-dev-tool-app-store-tool/"/>
    <updated>2013-06-16T12:26:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/06/16/ios-dev-tool-app-store-tool</id>
    <content type="html"><![CDATA[<p>本文首发于InfoQ，本文版权归InfoQ所有，转载请保留<a href="http://www.infoq.com/cn/articles/appstore-statistical-tool">原文链接</a>。</p>

<h2>前言</h2>

<p>随着iOS开发的流行，针对iOS开发涉及的方方面面，早有一些公司提供了专门的解决方案或工具。这些解决方案或工具包括：用户行为统计工具（友盟，Flurry，Google Analytics等),  App Store销售分析工具（例如App annie)， App crash收集工具（例如Crashlytics)，App测试发布工具（Test Flight）, App Push服务等。</p>

<p>这些解决方案或工具节省了iOS开发者大量的开发时间，但是由于相关介绍文章的缺乏，许多开发者都在重复着自己一次又一次重新造轮子。所以我希望，将我自己使用和调研的相关的第三方服务使用经验，整理成一系列文章，以便广大开发者能够省去大量的重复性工作。</p>

<p>今天介绍AppStore统计工具：App Annie和苹果的命令行统计工具。</p>

<!-- more -->


<h2>App Annie介绍</h2>

<p><img src="/images/app-annie-homepage.jpg"></p>

<p>苹果官方的iTunes Connect提供的销售数据统计功能比较弱，例如只能保存最近30天的详细销售数据，界面丑陋，
无法查看App的排名历史变化情况等。</p>

<p><a href="http://www.appannie.com/">AppAnnie</a>是一个专门为开发者提供的，针对AppStore相关数据的统计分析工具。
该工具可以统计App在AppStore的下载量，排名变化，销售收入情况以及用户评价等信息。</p>

<h3>原理</h3>

<p>AppAnnie实现的原理是：通过你配置的管理账号，向itunes connect请求获得你的App的相关数据，包括每日下载量，用户的评分数据，以及销售数据。</p>

<h3>注册Sales类型的账号</h3>

<p>使用AppAnnie，首先需要在苹果官方的itunes connect中配置一个Sales类型的账号。
因为默认的开发者账号是Admin级的权限，该权限是非常高的，可以修改App的价格或者直接下架商品。
如果将这个账号直接配置在AppAnnie中，虽然不影响其获得相关数据，但是有一定的账号安全风险。</p>

<p>配置该账号的详细步骤如下：</p>

<p>1、登录itunes connect，选择Manager Users</p>

<p><img src="/images/itunes-connect-add-user-1.jpg"></p>

<p>2、选择iTunes Connect User</p>

<p><img src="/images/itunes-connect-add-user-2.jpg"></p>

<p>3、点击Add new User</p>

<p><img src="/images/itunes-connect-add-user-3.jpg"></p>

<p>4、填写新用户的相关信息</p>

<p><img src="/images/itunes-connect-add-user-4.jpg"></p>

<p>5、勾选用户类型为Sales</p>

<p><img src="/images/itunes-connect-add-user-5.jpg"></p>

<p>6、选择Notifications为All Notifications。点击图中所指的位置即可全选。</p>

<p><img src="/images/itunes-connect-add-user-6.jpg"></p>

<p>7、之后，邮箱中会收到iTunes Connect发来的激活邮件。
点击邮件中的激活链接，即可进入到账号注册界面，之后注册账号即可激活。如果该邮箱已经注册过Apple Id，则会进入到登录界面，登录后即可激活。</p>

<p><img src="/images/itunes-connect-add-user-7.jpg"></p>

<h2>注册 App Annie账号及配置</h2>

<p>打开App Annie的官方网站:<a href="http://www.appannie.com/">http://www.appannie.com/</a>，
注册步骤和一般网站的步骤一样，我就不介绍了，注册完成之后的配置步骤如下：</p>

<p>1、在设置页面中增加iTunes Connect账号</p>

<p><img src="/images/app-annie-1.jpg"></p>

<p>2、填写你的之前在iTunes Connect中增加的Sales类型的账号及密码</p>

<p><img src="/images/app-annie-2.jpg"></p>

<p>3、在User Setting中勾选上接收每日Report</p>

<p><img src="/images/app-annie-3.jpg"></p>

<p>4、这样，每天就可以收到AppAnnie发来的相关统计邮件了。如下是一封粉笔网的销售报告邮件截图：</p>

<p><img src="/images/app-annie-4.jpg"></p>

<h2>官方的命令行工具</h2>

<p>如果你觉得将自己的销售数据交给第三方统计服务商，有一些不太安全。可以考虑使用苹果官方提供的Autoingestion.class工具来获得每天的销售数据，然后存到本地的数据库中。</p>

<p>该工具的下载地址是<a href="http://www.apple.com/itunesnews/docs/Autoingestion.class.zip">这里</a>，
苹果对于该用户的帮助文档在<a href="http://www.apple.com/itunesnews/docs/AppStoreReportingInstructions.pdf">这里</a>。</p>

<p>下面介绍一下这个工具的使用，将Autoingestion.class下载下来后，切换到class文件所在目录，执行如下命令，即可获得对应的统计数据：</p>

<p><code>
java Autoingestion &lt;帐号名&gt; &lt;密码&gt; &lt;vendorId&gt; &lt;报告类型&gt; &lt;时间类型&gt; &lt;报告子类型&gt; &lt;时间&gt;
</code></p>

<p>其中vendor Id在iTunes Connect的如下图所示位置获得，是一个数字8开头的序列。</p>

<p><img src="/images/itunes-connect-vendor-id.jpg"></p>

<p>&lt;报告类型>可选的值是：Sales 或 Newsstand</p>

<p>&lt;时间类型>可选的值是：Daily, Weekly, Monthly 或 Yearly</p>

<p>&lt;报告子类型>可选的值是：Summary, Detailed 或 Opt-In</p>

<p>&lt;时间>以如下的格式给出：YYYYMMDD</p>

<p>以下是一个示例，它将获得2013年5月8日的日销售摘要数据。</p>

<p><code>
java Autoingestion username@fenbi.com password 85587619 Sales Daily Summary 20130508
</code></p>

<p>我试用了一下该工具，觉得还是太糙了一些，仅仅能够将销售数据备份下来，如果要做AppAnnie那样的统计报表，还需要写不少代码。而且，该工具并不象App Annie那样，还提供应用在App Store的排名变化情况。虽然可以自己再做抓取，但也是需要工作量的。</p>

<h2>其它类似App Annie的服务</h2>

<p>类似App Annie这样的服务还有：<a href="http://appfigures.com">AppFigures</a>。我试用过之后，发现它不如App Annie功能强大。不过作为一个替代方案，也一并介绍给大家。</p>

<p>在Github上也有一些开源的<a href="https://github.com/alexvollmer/itunes-connect">统计工具</a>，感兴趣的朋友也可以尝试一下。这些工具基本上也就是对苹果的命令行工具的增强，例如增加了将数据导入到数据库中等功能。</p>

<h2>功能对比</h2>

<p>App Annie和苹果本身提供的命令行工具虽然都能统计App Store的数据，但是二者功能相差悬殊。苹果的命令行工具仅仅能提供销售数据的按日、周、月、年等方式的统计和备份。而App Annie除了以更加良好的界面和交互提供这些功能外，还能跟踪App的排名变化，以及App在苹果的各种榜单中所处位置的情况。</p>

<p>建议大家都可以尝试使用App Annie或AppFigures这类统计工具，帮助你方便地查看App的销售和排名情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[再见，viewDidUnload方法]]></title>
    <link href="http://blog.devtang.com/blog/2013/05/18/goodbye-viewdidunload/"/>
    <updated>2013-05-18T17:37:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/05/18/goodbye-viewdidunload</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>我在去年的一篇文章<a href="http://blog.devtang.com/blog/2012/02/06/new-methods-in-uiviewcontroller-of-ios5/">《iOS5中UIViewController的新方法》</a>中介绍了iOS5引入的关于ViewController的新方法。但是现在如果运行该文章中的Sample代码的话，你会发现Log中不会再出现viewDidUnload方法被调用的记录。这是因为在iOS6中，viewDidUnload回调方法被Deprecated掉了。查看苹果的文档，可以看到如下的说明。</p>

<p><img src="/images/viewdidunload-1.jpg"></p>

<p>那么，原本在viewDidUnload中的代码应该怎么处理？在iOS6中，又应该怎么处理内存警告？带着这些问题，我查找了一些资料，在此分享给大家。</p>

<!-- more -->


<h3>分析</h3>

<p>在iOS4和iOS5系统中，当内存不足，应用收到Memory warning时，系统会自动调用当前没在界面上的ViewController的viewDidUnload方法。
通常情况下，这些未显示在界面上的ViewController是UINavigationController Push栈中未在栈顶的ViewController，以及UITabBarViewController中未显示的子ViewController。这些View Controller都会在Memory Warning事件发生时，被系统自动调用viewDidUnload方法。</p>

<p>在iOS6中，由于viewDidUnload事件在iOS6下任何情况都不会被触发，所以苹果在文档中建议，应该将回收内存的相关操作移到另一个回调函数：didReceiveMemoryWarning 中。但是如果你仅仅是把以前写到viewDidUnload函数中的代码移动到didReceiveMemoryWarning函数中，那么你就错了。以下是一个 <font color=red>错误的示例代码</font> ：</p>

<p>``` objc</p>

<ul>
<li>(void)didReceiveMemoryWarning {
  [super didReceiveMemoryWarning];
  if([self isViewLoaded] &amp;&amp; ![[self view] window]) {

<pre><code>  [self setView:nil];
</code></pre>

<p>  }
}</p></li>
</ul>


<p>```</p>

<p><a href="http://thejoeconwayblog.wordpress.com/2012/10/04/view-controller-lifecycle-in-ios-6/">这篇文章</a>解释了iOS6不推荐你将view置为nil的原因（链接打开需要翻墙）, 翻译过来如下：</p>

<ol>
<li><p>UIView有一个CALayer的成员变量，CALayer是具体用于将自己画到屏幕上的。如下图所示：</p>

<p><img src="/images/viewdidunload-2.jpg"></p></li>
<li><p>CALayer是一个bitmap图象的容器类，当UIView调用自身的drawRect时，CALayer才会创建这个bitmap图象类。</p></li>
<li><p>具体占内存的其实是一个bitmap图象类，CALayer只占48bytes, UIView只占96bytes。而一个iPad的全屏UIView的bitmap类会占到12M的大小！</p></li>
<li><p>在iOS6时，当系统发出MemoryWarning时，系统会自动回收bitmap类。但是不回收UIView和CALayer类。这样即回收了大部分内存，又能在需要bitmap类时，通过调用UIView的drawRect: 方法重建。</p></li>
</ol>


<h3>内存优化</h3>

<p>另外文章中还提到苹果的操作系统对此做的一个内存优化技巧，解释如下：</p>

<ol>
<li><p>当一段内存被分配时，它会被标记成“In use“, 以防止被重复使用。当内存被释放时，这段内存会被标记成"Not in use"，这样，在有新的内存申请时，这块内存就可能被分配给其它变量。</p></li>
<li><p>CALayer包括的具体的bitmap内容的私有成员变量类型为<a href="http://blog.spacemanlabs.com/2011/08/calayer-internals-contents/">CABackingStore</a>， 当收到MemroyWarning时，
CABackingStore类型的内存区会被标记成volatile类型（这里的volatile和 C以及Java语言的volatile不是一个意思），volatile表示，这块内存可能被再次被原变量重用。</p></li>
</ol>


<p>这样，有了上面的优化后，当收到Memoy Warning时，虽然所有的CALayer所包含的bitmap内存都被标记成volatile了，但是只要这块内存没有再次被复用，那么当需要重建bitmap内存时，
它就可以直接被复用，而避免了再次调用 UIView的 drawRect: 方法。</p>

<h3>总结</h3>

<p>所以，简单来说，对于iOS6，你不需要做任何以前viewDidUnload的事情，更不需要把以前viewDidUnload的代码移动到 didReceiveMemoryWarning方法中。</p>

<p>引用WWDC 2012 中的一段话来给viewDidUnload说再见：</p>

<p><blockquote><p></p></p><p><p>The method viewWillUnload and viewDidUnload. We're not going to call them anymore. I mean, there's kind of a cost-benifit equation and analysis that we went through. In the early days, there was a real performance need for us to ensure that on memory warnings we unloaded views. There was all kinds of graphics and backing stores and so forth that would also get unloaded. We now unload those independently of the view, so it isn't that big of a deal for us for those to be unloaded, and there were so many bugs where there would be pointers into。</p></p><p><p></p></blockquote></p>

<h3>参考链接</h3>

<ul>
<li><a href="http://thejoeconwayblog.wordpress.com/2012/10/04/view-controller-lifecycle-in-ios-6/">View Controller Lifecycle in iOS 6</a></li>
<li><a href="http://blog.spacemanlabs.com/2011/08/calayer-internals-contents/">CALayer Internals: Contents</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[历史上的WWDC门票售空图片]]></title>
    <link href="http://blog.devtang.com/blog/2013/04/30/the-history-of-wwdc/"/>
    <updated>2013-04-30T22:40:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/04/30/the-history-of-wwdc</id>
    <content type="html"><![CDATA[<h2>2008年</h2>

<p>62天售空。介绍了iPhone 3G。</p>

<p><img src="http://blog.devtang.com/images/wwdc-2008.jpg" width="500px" /></p>

<h2>2009年</h2>

<p>33天售空。介绍了iPhone 3GS。</p>

<p><img src="http://blog.devtang.com/images/wwdc-2009.png" width="500px" /></p>

<h2>2010年</h2>

<p>8天售空。介绍了iPhone 4。</p>

<p><img src="http://blog.devtang.com/images/wwdc-2010.png" width="500px" /></p>

<h2>2011年</h2>

<p>12小时售空。介绍了iOS5, ARC, Storyboard, iCloud, Mac OS X Lion。</p>

<p>从这一年开始，iPhone新品都没能赶上在WWDC中介绍。</p>

<p><img src="http://blog.devtang.com/images/wwdc-2011.jpg" width="500px" /></p>

<h2>2012年</h2>

<p>2小时售空。介绍了iOS6。</p>

<p><img src="http://blog.devtang.com/images/wwdc-2012.jpg" width="500px" /></p>

<h2>2013年</h2>

<p>2分钟售空。期待。</p>

<p><img src="http://blog.devtang.com/images/wwdc-2013.jpg" width="500px" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[那些被遗漏的Objective-C保留字]]></title>
    <link href="http://blog.devtang.com/blog/2013/04/29/the-missing-objc-keywords/"/>
    <updated>2013-04-29T20:22:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/04/29/the-missing-objc-keywords</id>
    <content type="html"><![CDATA[<p><img src="/images/forget.jpeg"></p>

<p>今天翻到很久以前自己在网易博客上写的<a href="http://tangqiaoboy.blog.163.com/blog/static/116114258201110133108545/">这篇文章</a>，惊奇地发现自己都忘记了里面的一些内容。所以我又重新学习了一下，然后改了改内容，挪到这里。</p>

<h2>前言</h2>

<p><a href="http://www.amazon.cn/s?ie=UTF8&amp;search-alias=books&amp;field-author=Steffen%20Itterheim">Steffen Itterheim</a>是<a href="http://www.amazon.cn/Learn-Iphone-and-Ipad-Cocos2d-Game-Development-The-Leading-Framework-for-Building-2D-Graphical-and-Interactive-Applications-Itterheim-Steffen/dp/1430233036/ref=sr_1_1?ie=UTF8&amp;qid=1321168092&amp;sr=8-1">《Learn Iphone and Ipad Cocos2d Game Development》</a>作者。cocos2d和cocos2d-x现在已成为著名的游戏开发引擎。在AppStore上有超过100个游戏是基于Cocos2D。</p>

<p>Steffen Itterheim在<a href="http://www.learn-cocos2d.com/2011/10/complete-list-objectivec-20-compiler-directives">他的博客</a>中总结了 Objective-C 2.0 所有的编译器保留字，并且对这些保留字做了介绍和使用示例。这些保留字如下：</p>

<pre>
@class
@defs
@protocol @required @optional @end
@interface @public @package @protected @private @property @end
@implementation @synthesize @dynamic @end
@throw @try @catch @finally
@synchronized @autoreleasepool
@selector @encode
@compatibility_alias
@”string”
</pre>


<p>我把这些保留字过了一遍，发现很少用到的有 @dynamic @defs @encode @compatibility_alis，所以就给大家介绍一下这几个关键字吧。</p>

<!-- more -->


<h2>@dynamic</h2>

<p>@dynamic 是相对于 @synthesize的，它们用样用于修饰 @property，用于生成对应的的getter和setter方法。但是@ dynamic表示这个成员变量的getter和setter方法并不是直接由编译器生成，而是手工生成或者运行时生成。</p>

<p>示例如下：</p>

<p>``` objc
@implementation ClassName
@synthesize aProperty, bProperty;
@synthesize cProperty=instanceVariableName;
@dynamic anotherProperty;</p>

<p>// method implementations
@end
```</p>

<h2>@defs</h2>

<p>@defs 用于返回一个Objective-C类的struct结构，这个struct与原Objective-C类具有相同的内存布局。就象你所知的那样，Objective-C类可以理解成由基本的C struct加上额外的方法构成。</p>

<p>示例代码如下：</p>

<p><code>objc
struct { @defs( NSObject) }
</code></p>

<p>你可能会想，什么情况下才会需要使用这个关键字。答案是涉及非常底层的操作或优化的时候才会用到。像如这篇讨论<a href="http://www.mulle-kybernetik.com/artikel/Optimization/opti-3-imp-deluxe.html">Objective-C如何做缓存优化</a>的文章中，就用到了该关键字。</p>

<h2>@encode</h2>

<p>@encode 是用于表示一个类型的字符串，对此，苹果有专门的<a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">介绍文档</a></p>

<p>示例如下：</p>

<p>``` objc
-(void) aMethod
{</p>

<pre><code>char *enc1 = @encode(int);                 // enc1 = "i"
char *enc2 = @encode(id);                  // enc2 = "@"
char *enc3 = @encode(@selector(aMethod));  // enc3 = ":"

// practical example:
CGRect rect = CGRectMake(0, 0, 100, 100);
NSValue *v = [NSValue value:&amp;rect withObjCType:@encode(CGRect)];
</code></pre>

<p>}
```</p>

<h2>@compatibility_alis</h2>

<p>@compatibility_alis 是用于给一个类设置一个别名。这样就不用重构以前的类文件就可以用新的名字来替代原有名字。</p>

<p>示例如下：</p>

<p><code>objc
@compatibility_alias AliasClassName ExistingClassName
</code></p>

<h2>@autoreleasepool</h2>

<p>@autoreleasepool 是用于ARC下代替 NSAutoreleasePool的保留字，我把它写在这里，是想告诉那些以为ARC慢的同学，在苹果的<a href="http://developer.apple.com/library/ios/#releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">这篇官方文档</a>中有提到， @autoreleasepool 比 NSAutoreleasePool快6倍。当然，文档中也提到，ARC下不止Autorelease Pool的实现变快了，retain和release也快很多。如果你还没有在工程中使用ARC，推荐看看我的<a href="http://blog.devtang.com/blog/2013/03/27/should-we-use-arc/">《是否应该使用ARC》</a>。</p>

<h2>Cheat Sheet</h2>

<p>有一个热心者根据他的博文，制作了一张<a href="http://maniacdev.com/cheatsheetobjccd.pdf">《Objective-C 2.0保留字速查表》</a>，对于新手来说，把这张速查表打印出来，对于熟悉现在的保留字还是很有用的，它的下载地址是：<a href="http://maniacdev.com/cheatsheetobjccd.pdf">http://maniacdev.com/cheatsheetobjccd.pdf</a></p>

<p>五一节到了，祝大家节日快乐！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS应用内支付(IAP)的那些坑]]></title>
    <link href="http://blog.devtang.com/blog/2013/04/07/tricks-in-iap/"/>
    <updated>2013-04-07T20:14:00+08:00</updated>
    <id>http://blog.devtang.com/blog/2013/04/07/tricks-in-iap</id>
    <content type="html"><![CDATA[<p><img src="/images/iap-icon.jpg"></p>

<h2>前言</h2>

<!--
[udacity](https://www.udacity.com/)中的在线课程[《How to build a startup》](https://www.udacity.com/course/ep245)中提到，所谓创业，就是尝试寻找新的赢利模式。正因为这是一种尝试，所以不可避免地需要调整产品方向，寻找市场中还未被发现的用户需求，给用户创造价值，进而获得收入。最近很火的[精益创业](http://book.douban.com/subject/10945606/)的观点，则是强调将这种尝试成本降到最小，使得自己可以根据市场反馈迅速调整产品。-->


<p>我们在今年春节后上线了新的在线智能题库：<a href="http://yuantiku.com/">猿题库</a>。<!-- 这应该是我们在互联网教育这个创业领域的早已计划好的第二个方向。--></p>

<p>猿题库现在推出了公务员考试行测和申论2个产品，均包括web, iOS和Android三个平台。这次我们尝试做一个收费的产品，所以在iOS端集成了应用内支付（IAP）功能。在开发过程中和上线后，我们遇到了IAP中的一些坑，在此分享给各位。</p>

<!-- more -->


<h2>IAP 审核相关的坑</h2>

<p>IAP开发的详细步骤我写在<a href="http://blog.devtang.com/blog/2012/12/09/in-app-purchase-check-list/">另一篇博客</a>中了。在此主要介绍审核时遇到的问题。</p>

<h3>IAP类型错误</h3>

<p>由于我们是按月付费的产品，所以在设置IAP类型时，我没有经验，只是简单设置成了可重复消费(Consumable)的IAP项目。但是我不知道，苹果对于这种按时间收费的产品，应该使用不可更新的定阅（Non-Renewing Subscription）类型。这个类型设置错误造成了我们app的一次审核被拒。</p>

<h3>IAP验证逻辑</h3>

<p>由于苹果在iOS5.0以下有IAP的bug，使得攻击者可以伪造支付成功的凭证。而iOS6.0的系统在越狱后同样可以伪造凭证，所以我们对于应用内支付，增加了服务器端的验证。
服务器端会将支付凭证发给苹果的服务器进行二次验证，以保证凭证是真实有效的。</p>

<p>在我们公司的测试服务器中，我们会连接苹果的测试服务器（https://sandbox.itunes.apple.com/verifyReceipt）验证。</p>

<p>在我们部署在线上的正式服务器中，我们会连接苹果的正式服务器（https://buy.itunes.apple.com/verifyReceipt ）验证。</p>

<p>我们提交给苹果审核的是正式版，我们以为苹果审核时，我们应该连接苹果的线上验证服务器来验证购买凭证。结果我理解错了，苹果在审核App时，只会在sandbox环境购买，其产生的购买凭证，也只能连接苹果的测试验证服务器。但是审核的app又是连接的我们的线上服务器。所以我们这边的服务器无法验证通过IAP购买，造成我们app的又一次审核被拒。</p>

<p>解决方法是判断苹果正式验证服务器的返回code，如果是21007，则再一次连接测试服务器进行验证即可。苹果的<a href="http://developer.apple.com/library/ios/#documentation/NetworkingInternet/Conceptual/StoreKitGuide/RenewableSubscriptions/RenewableSubscriptions.html">这一篇文档</a>上有对返回的code的详细说明。</p>

<h2>IAP上线后的遇到的情况</h2>

<p>我们在服务器端增加了验证IAP是否有效的逻辑。在产品上线后，如我们所料，我们收到了大量的欺骗性购买，这些都被我们的服务器识别出来了，但是我们也遇到了以下这次没有想到的情况:</p>

<p>1、由于国内越狱用户的比例比较大(2012年底国内越狱比例是42%),所以虽然我们服务器会验证购买凭证，但是每天有超过50%以上的凭证都是伪造的。同时由于苹果的验证服务器在美国，凭证验证请求响应的时间比较慢，大量的伪造凭证发给苹果服务器，不知道会不会被苹果认为我们是在恶意进行DDOS。至少我们发现有些时候，验证请求会超时。</p>

<p>2、由于国内有许多小白用户，他们的手机从购买时就被渠道商帮忙越狱过了并且安装了IAP free插件。所以对于这类用户，他们即使想付费购买，由于系统原有的IAP支付功能已经被破坏，所以他们是无法正常付费的。麻烦的是，他们会以为这是我们的app的问题，转而给我们的客服打电话投诉。这让我们非常郁闷。</p>

<p>3、苹果的验证服务器有时候会出问题，我们发现本来约定好返回的JSON数据在有几次返回的居然是一个XML格式的文件。造成我们将正常的付费IAP凭证验证失败。所以，在服务器记录下所有的验证凭证非常有必要，一来可以防止黑客多次提交同一个成功凭证的重放攻击，二来在需要时可以手工进行再验证。</p>

<h2>越狱手机可能被黑客窃取购买凭证！！</h2>

<p>我们发现有一部分用户反馈说已经收到苹果的扣费账单，但是我们从服务器的验证记录看，他上传的凭证却是虚假的。由于这些用户不太多，我们一开始以为是用户在恶意欺骗我们，后来我们让他将苹果的付费账单邮件转发给我们，以及将itunes的购买记录截图转发给我们，随着讨论的深入，我们越来越怀疑这里面有一个黑色的产业链。越狱手机的正常购买凭证可能被黑客的恶意程序截获，具体的攻击方式我们讨论了一下，其实就是被<a href="http://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击</a>，详细的过程如下:</p>

<ol>
<li>越狱手机的在被破解后，可能从一些破解渠道安装了黑客的恶意程序。</li>
<li>黑客将越狱手机所有https请求都经过他的中间服务器。</li>
<li>当有支付请求时，黑客先将请求发给苹果服务器，待苹果将成功的凭证返回后，黑客将这个凭证替换成假的凭证，完全支付凭证的偷取。</li>
</ol>


<p>或许有人会问，这个凭证拿来有什么用呢?很简单 ，因为苹果为了保护用户的隐私，支付凭证中并不包含任何用户的apple id信息，所以我们的app和服务器无法知道这个凭证是谁买的，而只能知道这个凭证是真的还是假的。于是黑客就可以用这个凭证，在另外的账号中通知我们完成了购买，而发来的验证凭证又是真实的，所以我们的服务器就会误认为是黑客的账号完成了购买，继而把会员期算在黑客的账号上。</p>

<p>再举一个简单的例子，你拿500块钱买了顺风优选的500元购物券，由于这个购物券是不记名的，所以顺风优选无法知道是谁买的。如果这个购物券在发放过程中被人掉包，那么偷购物券的人就可以拿这个偷来的真购物券来购物，而顺风优选的卡因为是不记名的，所以也无法查证这件事情。在这个例子中，购物券的不记名和苹果的支付凭证无账号信息是同一个道理。</p>

<p>鉴于以上情况，考虑到越狱手机不但不能成功支付，还会有安全问题，所以我们在新版中取消了越狱手机中的IAP支付功能。</p>

<p><font color=red>所以，请大家还是不要越狱自己的手机，iPhone手机越狱后风险相当大。实在不值得为了免费玩几个游戏就丢掉安全性。</font></p>

<h2>后记</h2>

<h3>中间人攻击的演示</h3>

<p>iOS独立开发者<a href="http://weibo.com/indiebros">王轲_IndieBros</a>在他的博客文章<a href="http://www.iwangke.me/2013/02/18/get-itunes-raw-response-with-mitmproxy/">《使用mitmproxy获取iTunes 11的Raw HTTPs Response》</a>中演示了如何使用中间人攻击来修改Game Center游戏数据。王轲还把我的例子白话翻译了一下（可见我还是说得太绕了，囧）：</p>

<p><blockquote><p>坏人在购买过程中插了一腿，换走了用户的无记名发票（购物小票形象些），然后手持无记名小票伪装成真实顾客或者转手出售获利。</p></blockquote></p>

<h3>关于越狱与盗版</h3>

<p>不少细心的同学评论纠正我，指出越狱并不等同于使用盗版。确实，如果说严格的定义，越狱只是让iPhone获得root权限，进而可以做任何事情。如果越狱的同学在越狱后不安装IAP free插件，不使用app sync插件，不使用任何国内的和非bigboss的cydia源，不使用任何盗版软件，所有应用都是从app store官方网站上下载的话，被黑客攻击的可能性会降低一些。</p>

<p>即使这样，由于手机已经被root了，苹果的沙盒安全机制失效，所以风险还是很大的。</p>

<h3>关于越狱用户的比例</h3>

<p>有同学提出我文章中写的越狱手机比例太高了，想询问数据来源。这个比例主要来自我们自己的app的统计信息，以及结合国内的统计工具友盟的<a href="http://www.umeng.com/umengdata_reports">越狱手机比例统计</a>，去年底国内的越狱比例是42%。</p>
]]></content>
  </entry>
  
</feed>
